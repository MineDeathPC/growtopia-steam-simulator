<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            background-image: url("assets/bg.jpg");
            background-repeat: repeat;
            background-size: 15cm;
            margin: 0;
        }

        #inv-cont {
            position: fixed;
            top: 0;
            left: 0;
            width: auto;
            padding: 0;
            z-index: 10;
            background-color: rgba(4,158,129,0.5);
            border: 10px double darkcyan;
            border-radius: 20px;
        }

        #inv {
            display: grid;
            grid-template-columns: repeat(13, 50px); /* 13 items per row */
            gap: 6px;
            padding: 10px;
        }

        .inv-item {
            width: 40px;
            height: 40px;
            background-color: darkgrey;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid cyan;
            border-radius: 5px;
            overflow: hidden;
            cursor: pointer;
        }

        .inv-item img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(100, 40px); /* 100 columns with each cell 40px wide */
            grid-template-rows: repeat(100, 40px);    /* 100 rows with each cell 40px tall */
            gap: 1px;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        .grid-cell {
            width: 40px;
            height: 40px;
            background-color: rgba(100,255,255,0.07);
            border: 1px solid rgba(60,50,120,0.5);
            position: relative; /* For positioning steam puffs */
            overflow: hidden;
        }

        .grid-cell img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .steam-highlight {
            background-color: rgba(0, 255, 0, 0.3);
        }

        .steam-puff {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 0, 0.6); /* Translucent green for steam */
            border-radius: 50%;
            pointer-events: none; /* Ensure it doesn't block clicks */
        }

        @keyframes puff-animation {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        #toggle-hint {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 10;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
        }

        #load-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 20;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        #load-button input[type="file"] {
            display: none;
        }

        .activators {
            position: absolute;
            z-index: 1;
            font-size: 0.6cm;
            border: none;
            background: none;
            cursor: pointer;
        }

        .activators:hover {
          
        }
		
		.steam-puff{
			width:100%;
			height:100%;
			background-color:green;
			opacity:0.4;
		}
    </style>
</head>

<body>
    <div id="inv-cont">
        <div id="inv"></div>
    </div>

    <div id="grid"></div>

    <!-- Hint text for showing inventory -->
    <div id="toggle-hint">Press I to open Inventory</div>

    <!-- Load JSON Button -->
    <button id="load-button" alt="ctrl+s to save json">Load JSON</button>
    <input type="file" id="file-input" accept=".json" style="display: none;">

    <script>
        let inventoryVisible = false;

        function toggleInventory() {
            const invCont = document.getElementById('inv-cont');
            const toggleHint = document.getElementById('toggle-hint');
            
            if (inventoryVisible) {
                invCont.style.display = 'none';
                toggleHint.style.display = 'block'; // Show the hint text
            } else {
                invCont.style.display = 'block';
                toggleHint.style.display = 'none'; // Hide the hint text
            }

            inventoryVisible = !inventoryVisible; // Toggle state
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'i' || event.key === 'I') {
                toggleInventory();
            }
            if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                event.preventDefault(); // Prevent the default save dialog
                saveGrid();
            }
        });

        const activators = [
            { name: "steam engine" },
            { name: "steam revolver" },
            { name: "steam stomper" }
        ];
        const items = [
            { name: "steam tubes" },
            { name: "steam bellows" },
            { name: "steam riser bellows" },
            { name: "steam piston" },
            { name: "steam lifter piston" },
            { name: "steam collector" },
            { name: "steam engine" },
            { name: "steam crank" },
            { name: "steam crossover" },
            { name: "steam funnel up" },
            { name: "steam funnel down" },
            { name: "steam funnel left" },
            { name: "steam funnel right" },
            { name: "steam gear" },
            { name: "steam organ" },
            { name: "steam pipe" },
            { name: "steam revolver" },
            { name: "steam scrambler" },
            { name: "steam stomper" },
            { name: "steam vent" },
            { name: "steam valve" },
            { name: "steam door" },
            { name: "steam spikes" },
            { name: "steam lamp" },
            { name: "steam launcher" },
			{ name: "copper" }
        ];

        let selectedItem = null;
        let gridData = Array.from({ length: 100 }, () => Array(100).fill(null)); // 2D array for grid

        const inv = document.getElementById('inv');
        const grid = document.getElementById('grid');
        const fileInput = document.getElementById('file-input');

        items.forEach(item => {
            const div = document.createElement('div');
            div.classList.add('inv-item');
            
            const img = document.createElement('img');
            img.src = "assets/" + item.name.toLowerCase().replaceAll(" ", "-") + ".png";
            img.alt = item.name;

            div.addEventListener('click', () => {
                selectedItem = { name: item.name, orientation: 0 };
            });

            div.appendChild(img);
            inv.appendChild(div);
        });

        setTimeout(toggleInventory, 1000);
        setTimeout(toggleInventory, 1000);

        for (let i = 0; i < 10000; i++) {
            const cell = document.createElement('div');
			cell.id = `grid-cell-${i}`
            cell.classList.add('grid-cell');

            cell.addEventListener('click', () => placeBlock(cell, i));
            grid.appendChild(cell);
        }

        function placeBlock(cell, i) {
            const row = Math.floor(i / 100);
            const col = i % 100;

            if (cell.hasChildNodes()) {
                cell.innerHTML = '';
                cell.style.border = '1px solid rgba(60,50,120,0.5)';
                gridData[row][col] = null;

                const existingButton = document.getElementById(`activator-${i}`);
                if (existingButton) {
                    document.body.removeChild(existingButton);
                }
            } else if (selectedItem) {
                const img = document.createElement('img');
                img.src = "assets/" + selectedItem.name.toLowerCase().replaceAll(" ", "-") + ".png";
                img.alt = selectedItem.name;
                cell.appendChild(img);
                cell.style.border = 'none';
                gridData[row][col] = { 
                    name: selectedItem.name, 
                    orientation: selectedItem.orientation,
                    steam: false // Initialize steam status
                };

                if (activators.some(a => a.name === selectedItem.name)) {
                    let button = document.createElement("button");
                    button.id = `activator-${i}`;
                    button.classList.add("activators");
                    button.textContent = "▶️";
                    button.style.top = `${Math.floor(i / 100) * 40}px`;
                    button.style.left = `${(i % 100) * 40}px`;

                    button.addEventListener("click", () => {
                        alert(`Activator clicked at index ${i}`); // Alert for debugging  
                        steamSystem_main(Math.floor(i / 100), i % 100);
                    });

                    document.body.appendChild(button);
                }
            }
        }

        function saveGrid() {
            const gridJson = JSON.stringify(gridData);
            const blob = new Blob([gridJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'grid.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = () => {
                    gridData = JSON.parse(reader.result);
                    updateGridFromData();
                };
                reader.readAsText(file);
            }
        });

        function updateGridFromData() {
            gridData.forEach((row, r) => {
                row.forEach((cell, c) => {
                    const cellDiv = grid.children[r * 100 + c];
                    if (cellDiv) {
                        if (cell) {
                            cellDiv.innerHTML = '';
                            const img = document.createElement('img');
                            img.src = "assets/" + cell.name.toLowerCase().replaceAll(" ", "-") + ".png";
                            img.alt = cell.name;
                            cellDiv.appendChild(img);

                            if (activators.some(a => a.name === cell.name)) {
                                let button = document.createElement("button");
                                button.id = `activator-${r * 100 + c}`;
                                button.classList.add("activators");
                                button.textContent = "▶️";
                                button.style.top = `${r * 40}px`;
                                button.style.left = `${c * 40}px`;

                                button.addEventListener("click", () => {
                                    alert(`Activator clicked at index ${r * 100 + c}`); // Alert for debugging  
                                    steamSystem_main(r, c);
                                });
                                document.body.appendChild(button);
                            }
                        } else {
                            cellDiv.innerHTML = '';
                            cellDiv.style.border = '1px solid rgba(60,50,120,0.5)';
                        }
                    }
                });
            });
        }

        const standard_behaviour = [
            "steam tubes",
            "steam bellows" ,
            "steam riser bellows",
            "steam piston",
            "steam lifter piston",
            "steam gear"
        ];

        function adj(row, col) {
            const adjacent = [];
            const rows = gridData.length;
            const cols = gridData[0].length;
            
            // Up
            adjacent.push(row > 0 ? gridData[row - 1][col] || "null" : "null");
            // Down
            adjacent.push(row < rows - 1 ? gridData[row + 1][col] || "null" : "null");
            // Left
            adjacent.push(col > 0 ? gridData[row][col - 1] || "null" : "null");
            // Right
            adjacent.push(col < cols - 1 ? gridData[row][col + 1] || "null" : "null");
            
            console.log(adjacent);
            return adjacent;
        }
		
		let Steam_index = 0;
		let Steam_Puffs = []
		let camefrom =[
		 "D",
			"U",
		   "R",
			"L"
			
		]
		let camefrom_2 =[
		 "R",
		 "L",
		 "D",
		 "U"
		]
		
		let propagateTo = {
		//camefrom:goingto
		U:"D",
		D:"U",
		R:"L",
		L:"R"
		}
		let propagateTo_mapper = {//right:valid mapper
		//camefrom:goingto
		U:3,
		D:2,
		R:1,
		L:0
		}
		let propagateTo_mapper_2 = {//left:valid mapper
		//camefrom:goingto
		U:2,
		D:3,
		R:0,
		L:1
		}
		
		function depletePuffs(){
		if(Steam_Puffs.length == 0)
			return;
		     
			Steam_Puffs.forEach((puff)=>{
			try{
				if(puff.totalLifetime > 0){
						puff.totalLifetime-=1;
					}
			    else if(puff.totalLifetime == 0){
			        	document.getElementById("puff-"+puff.steam_index).remove()
						Steam_Puffs = Steam_Puffs.filter(a=>a.steam_index==puff.steam_index)
						
					}
					
			}catch(e){
			e = ""
			console.log("_")
			}
			})
			
			
		}
		
		
		
		function movePuffToNewCell(puff, newRow, newCol) {
    // Get the current cell and new cell in the grid
    const currentCell = document.getElementById(`grid-cell-${puff.position[0] * 100 + puff.position[1]}`);
    const newCellIndex = newRow * 100 + newCol;
    const newCell = document.getElementById(`grid-cell-${newCellIndex}`);

    // Find the puff element in the current cell
    const puffElement = document.getElementById(`puff-${puff.steam_index}`);
    if (puffElement) {
        // Remove puff element from the current cell
        if (currentCell) {
            currentCell.removeChild(puffElement);
        }

        // Append puff element to the new cell
        if (newCell) {
		puffElement.style.top = "0px"
		puffElement.style.left = "0px"
            newCell.appendChild(puffElement);
        }

        // Update puff's position
        puff.position = [newRow, newCol];
    }
}





	class Puff {
    constructor(cameFromDirection, position = [0, 0], totalLifetime = 10, distanceTraveled = 0, steam_index = 0) {
        this.cameFromDirection = cameFromDirection;
        this.totalLifetime = totalLifetime;
        this.distanceTraveled = distanceTraveled;
        this.position = position;
        this.steam_index = steam_index;
        this.totalDistanceTraveled = 0; // New property
        Steam_Puffs.push(this); // add to collection of steam puffs
        console.log(Steam_Puffs);
        Steam_index++;
    }
    
    spawn_puff() {
        // Define or calculate newPosition based on the current position and direction
        // This is a placeholder; replace with your actual logic   
        const newCell = document.getElementById(`grid-cell-${parseInt(this.position[0]) * 100 + parseInt(this.position[1])}`);
        if (newCell) {
            // Create and display a new steam puff element
            const puffElement = document.createElement('div');
            puffElement.id = "puff-" + this.steam_index;
            puffElement.innerHTML = this.steam_index;
            puffElement.classList.add('steam-puff');
            puffElement.style.top = '0px'; // Adjust as necessary
            puffElement.style.left = '0px'; // Adjust as necessary
            newCell.appendChild(puffElement);
            setTimeout(() => { this.recursive_move(); }, 1000);
        }
    }
    
  recursive_move() {
    console.log('rec');
    console.log(this.position);
    let adjCells = adj(this.position[0], this.position[1]);

    let ValidArr = [
        standard_behaviour.includes(adjCells[0] === "null" ? "null" : adjCells[0].name), //up
        standard_behaviour.includes(adjCells[1] === "null" ? "null" : adjCells[1].name), //down
        standard_behaviour.includes(adjCells[2] === "null" ? "null" : adjCells[2].name), //left
        standard_behaviour.includes(adjCells[3] === "null" ? "null" : adjCells[3].name) //right
    ];

    console.log("-TEST", ValidArr[0] + "" + ValidArr[1] + "" + ValidArr[2] + "" + ValidArr[3]);
    console.log("-TEST", adjCells[0].name + "" + adjCells[1].name + "" + adjCells[2].name + "" + adjCells[3].name);

    if (ValidArr[0] || ValidArr[1] || ValidArr[2] || ValidArr[3]) { // at least 1 side is valid for propagation
        console.log("TEST");
        console.log(camefrom[camefrom.indexOf(this.cameFromDirection)]);
        console.log(ValidArr[camefrom.indexOf(this.cameFromDirection)]);

        if (camefrom[camefrom.indexOf(this.cameFromDirection)]) {
            // Straight motion in linear direction
            if (ValidArr[camefrom.indexOf(this.cameFromDirection)]) {
                console.log('straight');

                if (propagateTo[this.cameFromDirection] === "U") // move up to cell above
                    this.moveAndUpdateDirection(this.position[0] - 1, this.position[1], 'D');
                else if (propagateTo[this.cameFromDirection] === "D") // move down to cell below
                    this.moveAndUpdateDirection(this.position[0] + 1, this.position[1], 'U');
                else if (propagateTo[this.cameFromDirection] === "L") // move to left cell
                    this.moveAndUpdateDirection(this.position[0], this.position[1] - 1, 'R');
                else if (propagateTo[this.cameFromDirection] === "R") // move to right cell
                    this.moveAndUpdateDirection(this.position[0], this.position[1] + 1, 'L');

                setTimeout(() => { this.recursive_move(); }, 100);
            } 
            // Right motion
            else if (ValidArr[propagateTo_mapper[propagateTo[this.cameFromDirection]]]) {
                console.log('right');

                if (propagateTo_mapper[propagateTo[this.cameFromDirection]] === 0) //U
                    this.moveAndUpdateDirection(this.position[0] - 1, this.position[1], 'D');
                else if (propagateTo_mapper[propagateTo[this.cameFromDirection]] === 1) //D
                    this.moveAndUpdateDirection(this.position[0] + 1, this.position[1] - 1, 'U');
                else if (propagateTo_mapper[propagateTo[this.cameFromDirection]] === 2) //L
                    this.moveAndUpdateDirection(this.position[0], this.position[1] - 1, 'R');
                else if (propagateTo_mapper[propagateTo[this.cameFromDirection]] === 3) //R
                    this.moveAndUpdateDirection(this.position[0], this.position[1] + 1, 'L');

                setTimeout(() => { this.recursive_move(); }, 100);
            }
            // Left motion
            else if (ValidArr[propagateTo_mapper_2[propagateTo[this.cameFromDirection]]]) {
                console.log('left');

                if (propagateTo_mapper_2[propagateTo[this.cameFromDirection]] === 0) //U
                    this.moveAndUpdateDirection(this.position[0] - 1, this.position[1], 'D');
                else if (propagateTo_mapper_2[propagateTo[this.cameFromDirection]] === 1) //D
                    this.moveAndUpdateDirection(this.position[0] + 1, this.position[1] - 1, 'U');
                else if (propagateTo_mapper_2[propagateTo[this.cameFromDirection]] === 2) //L
                    this.moveAndUpdateDirection(this.position[0], this.position[1] - 1, 'R');
                else if (propagateTo_mapper_2[propagateTo[this.cameFromDirection]] === 3) //R
                    this.moveAndUpdateDirection(this.position[0], this.position[1] + 1, 'L');

                setTimeout(() => { this.recursive_move(); }, 100);
            }
        }
    } else {
        // No valid moves, remove the puff
		console.log("no moves")
        this.removePuff();
    }
}

    moveAndUpdateDirection(newRow, newCol, newCameFromDirection) {
        movePuffToNewCell(this, newRow, newCol);
        this.cameFromDirection = newCameFromDirection;
        this.totalDistanceTraveled += 1; // Increment distance traveled

        if (this.totalDistanceTraveled >= 40) {
            this.removePuff();
        }
    }

    removePuff() {
    // Remove puff element from the DOM
    const puffElement = document.getElementById(`puff-${this.steam_index}`);
    if (puffElement) {
        puffElement.remove();
    }

    // Remove puff from the Steam_Puffs collection
    const index = Steam_Puffs.findIndex(puff => puff.steam_index === this.steam_index);
    if (index > -1) {
        Steam_Puffs.splice(index, 1);
    }

    console.log(`Puff ${this.steam_index} removed`);
}
}

		
			
			

        function steamSystem_main(act_r, act_c) {        
            console.log(gridData);
            const adjCells = adj(act_r, act_c);

            // Log adjacent cells for debugging
            adjCells.forEach((cell, index) => {
                console.log(`Adjacent ${index}: ${cell === "null" ? "null" : cell.name}`);
            });

            if (standard_behaviour.includes(adjCells[0] === "null" ? "null" : adjCells[0].name)) {
                alert('up');
				let _puff = new Puff('D',[act_r-1,act_c]); //Came from Down-1
				_puff.spawn_puff();
            }
			else if (standard_behaviour.includes(adjCells[1] === "null" ? "null" : adjCells[1].name)) {
                alert('down');
				let _puff = new Puff('U',[act_r+1,act_c]); //Came from Up+1
				_puff.spawn_puff();
            }
			else{
				//nowhere to propagate to
			}
        }
    </script>
</body>
</html>
