<!DOCTYPE html>
<!--This program was created by MineDeath, Instagram: minedeath.gt-->
<!--Growtopia is licensed by Ubisoft, I do not own the game or its assets in any way-->




<html>
<head>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
<link rel="manifest" href="manifest.json">
<link rel="stylesheet" href="main.css">

 <title>Steam Simulator</title>
    <!--ustom PNG favicon -->
    <link rel="icon" type="image/png" href="assets/steam-tubes.png">
<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1"/>

</head>

<body>
  <div class="orientation-message"style="color:white;">
        Please rotate your device to landscape mode.
    </div>
	
	  <div class="content">
    <div id="inv-cont">
        <div id="inv"></div>
    </div>
	

    <div id="grid"></div>
	
	<div id="top-bar"></div>
   

    <!-- Hint text for showing inventory -->
    <button id="toggle-hint" onclick="toggleInventory()">Tap or press I to open/close Inventory</button>
	
	

    <!-- Toggle Grid Button -->
    <button id="show_grid_button" alt="toggle grid" onclick="mobileToggle()">Toggle Grid (G)</button>
	
	 
     <button id="save_build_button" onclick="saveBuild2()">Save Build</button>
	 <button id="load_build_button" onclick="loadBuild2()">Load Build</button>
	 <button id="load_example_build_button" style="display:none;">Load Examples</button>
    <div id="example-builds-container" style="display:none; position:fixed; width:50%; height:50%; z-index:15; top:50%; left:50%; transform:translate(-50%, -50%); padding:20px; background:white; border:1px solid 	#ccc; box-shadow:0px 0px 10px rgba(0, 0, 0, 0.1);"></div>
	
	
<div class="fixed-text">Created By: <i style="color:rgb(255,255,30);">  MineDeath </i></div>
	
<!-- end of all content-->
</div>
<input type="file" id="file-input" style="display:none;" onchange="loadFile(event)"/>
<!-- wait for body to fully load-->
<script src = "sweetalert.js"></script>
<script src = "index.js"></script>
<script>


function saveBuild2(){swal("404","not implemented yet, sorry!","error")}
function loadBuild2(){swal("404","not implemented yet, sorry!","error")}


//min,max are inclusive
function randomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

	function unique(length) {
		let result = '';
		const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
		const charactersLength = characters.length;
		let counter = 0;
		while (counter < length) {
		  result += characters.charAt(Math.floor(Math.random() * charactersLength));
		  counter += 1;
		}
		
		console.log(result)
		return result;
	}



let selectedItem = null


const itemsWithState = ["steam crank", "steam door"];

// Function to extract the specific state based on the block type
function getBlockState(block) {
    if (!block) return null;

    // Handle specific blocks that retain different types of state
    if (block.name === "steam crank") {
		console.log("saved+"+block.flow)
        return block.flow; // Return the flow state for cranks
    } else if (block.name === "steam door") {
		console.log("saved+"+block.state)
        return block.state; // Return the door state for doors (e.g., "open" or "closed")
    } else {
        return null; // No state to save for other blocks
    }
}

// Save build function
// Save build function
function saveBuild() {
    swal("BETA", "Saving and loading builds is still in beta development, expect bugs!", "warning");
    
    const simplifiedGridData = gridData.map(row => 
        row.map(block => {
            if (block) {
                if (itemsWithState.includes(block.name)) {
                    console.log("saved++" + getBlockState(block));
                    return { name: block.name, state: getBlockState(block) }; // Save both name and specific state
                } else {
                    return { name: block.name }; // Save only the name for other blocks
                }
            } else {
                return "null"; // Use the string "null" for empty slots
            }
        })
    );

    const blob = new Blob([JSON.stringify(simplifiedGridData)], { type: "application/json" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "steam_simulator_build.json";
    link.click();
}

// Load build function
// Load build function
function loadBuild() {
    swal("BETA", "Saving and loading builds is still in beta development, expect bugs!", "warning");
    document.getElementById('file-input').click(); // Trigger file input
}

// Load build function
function loadFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        const content = e.target.result;
        try {
            const loadedGridData = JSON.parse(content);
            resetGrid(); // Clear the existing grid before loading

            // Apply loaded data to the grid
            loadedGridData.forEach((row, rowIndex) => {
                row.forEach((blockData, colIndex) => {
                    if (blockData == "null") {
                        blockData = null; // Convert "null" string to null
                    }
                    if (blockData!=null&&blockData!="null") {
                        selectedItem = { name: blockData.name, orientation: 0 }; // Reset orientation by default
                        
                        // Check if the block has a saved state and restore it
                        if (blockData.state) {
                            restoreBlockState(blockData, blockData.state, rowIndex, colIndex); // Restore the specific state and update image
                        }

                        // Use the existing placeBlock function for placing the block
                        placeBlock(document.getElementById(`grid-cell-${rowIndex * 100 + colIndex}`), rowIndex * 100 + colIndex);
                    }
                });
            });
        } catch (err) {
            alert("Failed to load build. Invalid file format.");
            console.error("Error loading file:", err);
        }
    };
    reader.readAsText(file);
}



// Function to restore the specific block state during loading
// Function to restore the specific block state during loading
// Function to restore the specific block state during loading
function restoreBlockState(block, state,row=null,col=null) {
setTimeout(()=>{
    if (!block) return;

    if (block.name === "steam crank") {
        gridData[row][col].flow = state; // Set the flow state directly
        gridData[row][col].updateImg(row,col); // Update the crank image based on the restored flow
    } else if (block.name === "steam door") {
         gridData[row][col].state = state; // Set the door state directly
          gridData[row][col].updateImg(row,col); // Update the door image based on state
    }
	},1000)
}


// Function to reset the grid visually and in gridData
function resetGrid() {
    for (let i = 0; i < 10000; i++) {
        const cell = document.getElementById(`grid-cell-${i}`);
        if (cell) {
            cell.innerHTML = '';
            cell.style.border = '1px solid rgba(60,50,120,0.5)';
        }
    }
    gridData = Array.from({ length: 100 }, () => Array(100).fill(null)); // Reset gridData
}


		//audio controls
		
		// Create an AudioContext		
		let audioContext = null;
		document.body.onclick = function(){
		if(audioContext)
			return;
		audioContext = new (window.AudioContext || window.webkitAudioContext)()
		};

		// Function to play a tone
		function playTone(frequency, duration) {
			const oscillator = audioContext.createOscillator();
			oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
			oscillator.type = 'sine';
			oscillator.connect(audioContext.destination);
			oscillator.start();
			oscillator.stop(audioContext.currentTime + duration);
		}

		

	
		let grid_view_toggle = false;

		function showGridBorder() {
			Array.from(document.getElementsByClassName("grid-cell")).forEach((e)=>{
				e.style.border = "2px groove rgba(0,0,0,0)"
			})
		}

		function hideGridBorder() {
		Array.from(document.getElementsByClassName("grid-cell")).forEach((e)=>{
			 e.style.border = "2px groove rgba(0,230,230,0.4)"
			 })
		}




		//toggle grid shortcut
		document.addEventListener('keydown', function(event) {
			if (event.key === 'g' || event.key === 'G') {
				grid_view_toggle = !grid_view_toggle;
				if (grid_view_toggle) {
					showGridBorder()
				} else {
					hideGridBorder()
				}
			}
		});
		
		
		
		
		
		
		//toggle grid for mobile
		function mobileToggle(){
		grid_view_toggle = !grid_view_toggle;
				if (grid_view_toggle) {
					showGridBorder()
				} else {
					hideGridBorder()
				}
		}
	
	
	
	
	
	
	
        let inventoryVisible = false;


		
		
		
		
        function toggleInventory() {
            const invCont = document.getElementById('inv-cont');
            const toggleHint = document.getElementById('toggle-hint');
            
            if (inventoryVisible) {
                invCont.style.display = 'none';
               // toggleHint.style.display = 'block'; // Show the hint text
            } else {
                invCont.style.display = 'block';
               // toggleHint.style.display = 'none'; // Hide the hint text
            }

            inventoryVisible = !inventoryVisible; // Toggle state
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'i' || event.key === 'I') {
                toggleInventory();
            }
            if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                event.preventDefault(); // Prevent the default save dialog
				alert("not currently functional, sorry")
				return;
                saveGrid();
            }
        });
		
		
		
		//important constants
		const global_true_puff_speed = 100 //0.1s default
		const collector_puff_speed = 300;//0.3s (default)
		const max_puff_distance = 99;//99 (based on actual game)
		const global_collector_max_duration = 20000; //20s, 20000ms
		const global_vent_max_duration = 3000 //3 sec
		const global_organ_max_duration = 110;
		const global_organ_frequency = 500;
		const global_lamp_max_duration = 10000; //10s, 10000ms
		const global_engine_interval = 3000; //3s
		
		
		let activator_custom_function = {};
		let change_image_all_functions = {};
		
		
		

        
        const items = [
            { name: "steam tubes" },
			{ name: "steam gear" },
            { name: "steam bellows" },
            { name: "steam riser bellows" },
            { name: "steam piston" },
            { name: "steam lifter piston" },
            { name: "steam collector" },            
            { name: "steam funnel up" },
            { name: "steam funnel down" },
            { name: "steam funnel left" },
            { name: "steam funnel right" },
			{ name: "steam crank" },
			{ name: "steam valve left" },
			{ name: "steam valve right" },
			{ name: "steam crossover URDL" },
			{ name: "steam crossover ULDR" },
			{ name: "steam scrambler" },      
			{ name: "steam organ" },			
            { name: "steam pipe",hide:null},
			{ name: "steam vent L" },     
			{ name: "steam vent R" },   	
            { name: "steam revolver" },
			{ name: "steam stomper" },
			{ name: "steam engine L" },     
			{ name: "steam engine R" },   			
            { name: "steam door" },
			{ name: "steam launcher" },
            { name: "steam spikes" },
            { name: "steam lamp" },
           
			{ name: "copper" }
        ];
		
		
		
		  const standard_behaviour = [ 
            "steam tubes",
            "steam bellows" ,
            "steam riser bellows",
            "steam piston",
            "steam lifter piston",		
            "steam gear",
			
			
			
			"steam valve left",
			"steam valve right",
			"steam crank",
			"steam collector",
			"steam crossover URDL",
			"steam crossover ULDR",
			"steam vent L",
			"steam vent R",
		    "steam organ",
			"steam lamp",
			"steam launcher",
			"steam scrambler",
			
			"steam door",
			"steam spikes"
        ];
		
		
		const activators = [    
            { name: "steam revolver" },
            { name: "steam stomper" },
			{ name: "steam engine L" },
			{ name: "steam engine R" },
			
			
        ];
		
		const single_powered = [    
            { name: "steam door" },
            { name: "steam spikes" },
			{ name: "steam lamp" },
		    { name: "steam launcher" }
        ];


        
        let gridData = Array.from({ length: 100 }, () => Array(100).fill(null)); // 2D array for grid

        const inv = document.getElementById('inv');
        const grid = document.getElementById('grid');
        const fileInput = document.getElementById('file-input');

        items.forEach(item => {
			if(item.hasOwnProperty("hide")){
				return; //equal to continue in forEach
				}
				
            const div = document.createElement('div');
            div.classList.add('inv-item');
            
            const img = document.createElement('img');
            img.src = "assets/" + item.name.toLowerCase().replaceAll(" ", "-") + ".png";
            img.alt = item.name;

            div.addEventListener('click', () => {
                selectedItem = { name: item.name, orientation: 0 };
            });

            div.appendChild(img);
            inv.appendChild(div);
        });

        


        //GENERATE MAIN 100 BY 100 GRID
        function GenerateMainGrid(){
			for (let i = 0; i < 10000; i++) {
				const cell = document.createElement('div');
				cell.id = `grid-cell-${i}`
				cell.classList.add('grid-cell');

				cell.addEventListener('click', () => placeBlock(cell, i));
				grid.appendChild(cell);
			}
		}
		
		
		
		//WHEN PAGE IS FULLY LOADED
		window.onload = function(){
			setTimeout(toggleInventory, 1000);
			setTimeout(toggleInventory, 1000);
			GenerateMainGrid()
		}
		
		
		
		
		
		
		//changing image of a block in grid at row,col
		let image_change_queue = {}
		function changeBlockImage(row, col, image) {
			let unique_1 = unique(25)
			image_change_queue[unique_1] = function(){
				const cell = document.getElementById(`grid-cell-${row * 100 + col}`);
				if (cell && cell.hasChildNodes()) {
					const img = cell.querySelector('img');
					if (img) {
						img.src = image;
					}
				}			
			}
			setTimeout(image_change_queue[unique_1],100)
		}


		//main function to handle placing blocks on the grid
//main function to handle placing blocks on the grid
		function placeBlock(cell, i, control="build", saved_value=[]) {
	
		if(!selectedItem){
			return
		}
			const row = Math.floor(i / 100);
			const col = i % 100;

			if (cell.hasChildNodes()) {
				cell.innerHTML = '';
				cell.style.border = '2px groove  rgba(0,230,230,0.4)';
				gridData[row][col] = "null";

				let existingButton = document.getElementById(`activator-${i}`);
				if (existingButton) {
					document.body.removeChild(existingButton);
					existingButton.remove()
				}
			} else if (selectedItem &&selectedItem.hasOwnProperty("name")) {
		
				const img = document.createElement('img');
				img.src = "assets/" + selectedItem.name.toLowerCase().replaceAll(" ", "-") + ".png";
				img.alt = selectedItem.name;
				cell.appendChild(img);
				cell.style.border = 'none';
				

				//handling how the object should be, depending on block
				//this can be overwritten later
				gridData[row][col] = {
					name: selectedItem.name
				};


				//handle valve block placement
				if (selectedItem.name.includes("valve")) {
					let _orientation = (selectedItem.name.includes("left")) ? "L" : "R";
					gridData[row][col] = new steam_valve(selectedItem.name, _orientation);
					console.log("valve placed-> " + gridData[row][col].orientation);
					return;
				}


				//handle steam collector block placement
				if (selectedItem.name.includes("collector")) {
					gridData[row][col] = new Steam_Collector(selectedItem.name, []);
					console.log("steam collector placed");
					return;
				}



				//block is an activator block, create activator button, (standard for all non continuous steam generators)
				if (activators.some(a => a.name === selectedItem.name) && !selectedItem.name.includes(" door") && !selectedItem.name.includes(" crank") && !selectedItem.name.includes(" vent")) {
					let button = document.createElement("button");
					button.id = `activator-${i}`;
					button.classList.add("activators");
					button.textContent = "â–¶ï¸";

					button.style.top = `${Math.floor(i / 100) * 40}px`;
					button.style.left = `${(i % 100) * 40}px`;
					
					
					
					//activators engines/revolver/stomper
				   if(selectedItem.name.includes("stomper")){
					button.addEventListener("click", () => {
						console.log("activator button active")
						console.log(selectedItem.name)	
						let unique_1 = unique(15);
						activator_custom_function[unique_1] = function(){ steamSystem_main2(Math.floor(i / 100), i % 100,selectedItem.name) }
						activator_custom_function[unique_1]();
					});
					}
					
					if(selectedItem.name.includes("revolver")){
					button.addEventListener("click", () => {
						console.log("activator button active")
						console.log(selectedItem.name)	
						let unique_1 = unique(15);
					    activator_custom_function[unique_1] = function(){ steamSystem_main(Math.floor(i / 100), i % 100) }
						activator_custom_function[unique_1]();
					});
					}
					
					//left facing engine
					//right facing engine
					if (selectedItem.name.includes("engine L")) {
						gridData[row][col] = new steam_engine(selectedItem.name,false,null)
						console.log("Engine detected");

						button.addEventListener("click", () => {
							console.log("Activator button active");
							console.log(selectedItem.name);
							
							
								if (!gridData[row][col].active) {
									// Start the interval if not active
									gridData[row][col].interval = setInterval(() => {
										steamSystem_main4(Math.floor(i / 100), i % 100);
									}, global_engine_interval);
									steamSystem_main4(Math.floor(i / 100), i % 100);
									
									gridData[row][col].active = true;
									button.textContent = "âŽ"
								} else {
									// Clear the interval if already active
									clearInterval(gridData[row][col].interval);
									gridData[row][col].active = false;
									button.textContent = "â–¶ï¸"
								}
							
						});
				}
					
					//right facing engine
					if (selectedItem.name.includes("engine R")) {
						gridData[row][col] = new steam_engine(selectedItem.name,false,null)
						console.log("Engine detected");

						button.addEventListener("click", () => {
							console.log("Activator button active");
							console.log(selectedItem.name);
							
							
								if (!gridData[row][col].active) {
									// Start the interval if not active
									gridData[row][col].interval = setInterval(() => {
										steamSystem_main3(Math.floor(i / 100), i % 100);
									}, global_engine_interval);
									steamSystem_main3(Math.floor(i / 100), i % 100);
									
									gridData[row][col].active = true;
									button.textContent = "âŽ"
								} else {
									// Clear the interval if already active
									clearInterval(gridData[row][col].interval);
									gridData[row][col].active = false;
									button.textContent = "â–¶ï¸"
								}
							
						});
				}

					

					document.body.appendChild(button);
					button.style.opacity = "0.9"
					return;
				}

				//placing a steam crank
				if (selectedItem.name.includes("steam crank")) {
				
					let crank = new steam_crank(selectedItem.name);
					gridData[row][col] = crank;
					
					if(control == "load"){
						gridData[row][col].flow = saved_value[0];
					}

					let button = document.createElement("button");
					button.id = `activator-${i}`;
					button.classList.add("activators");
					button.textContent = "ï¸ðŸ”„";
					button.style.top = `${Math.floor(i / 100) * 40}px`;
					button.style.left = `${(i % 100) * 40}px`;

					button.addEventListener("click", () => {
						crank.toggleFlow();
						changeBlockImage(row, col, crank.getImage()) 
						console.log("steam crank rotated");
					});

					document.body.appendChild(button);
					return;
				}


				//placing a steam organ
				if (selectedItem.name.includes("steam organ")) {
					console.log("organ placed");
					let organ = new Steam_Organ(selectedItem.name, "off");
					gridData[row][col] = organ;
				}

				//placing a steam door
				if (selectedItem.name.includes("door")) {
					console.log('steam door placed');
					let door = new steam_door(selectedItem.name, "closed", row, col);
					gridData[row][col] = door; // Store the door in the grid

					let button = document.createElement("button");
					button.id = `activator-${i}`;
					button.classList.add("activators");
					button.textContent = "ï¸ðŸ”˜";
					button.style.top = `${Math.floor(i / 100) * 40}px`;
					button.style.left = `${(i % 100) * 40}px`;

					// Add event listener to toggle the state
					button.addEventListener("click", () => {
						let currentDoor = gridData[row][col]; // Get the existing door from the grid
						currentDoor.toggleState(); // Toggle the door's state
						changeBlockImage(row, col, currentDoor.getImage());  // Update the image
						console.log("steam door state changed: " + currentDoor.state);
					});

					document.body.appendChild(button);
					return;
				}
				
				if (selectedItem.name.includes("launcher")) {
					console.log('steam launcher placed');
					let launcher = new steam_launcher(selectedItem.name, "off");
					gridData[row][col] = launcher; // Store the launcher in the grid

					let button = document.createElement("button");
					button.id = `activator-${i}`;
					button.classList.add("activators");
					button.textContent = "ï¸â®";
					button.style.top = `${Math.floor(i / 100) * 40}px`;
					button.style.left = `${(i % 100) * 40}px`;

					// Add event listener to toggle the state
					button.addEventListener("click", () => {
						let currentLauncher = gridData[row][col]; // Get the existing launcher from the grid
						currentLauncher.deactivate() // Toggle the launcher's state
						currentLauncher.updateImg(row,col)
						console.log("steam launcher state changed: " + currentLauncher.state);
					});

					document.body.appendChild(button);
					return;
				}

				
				//placing steam vent
				if (selectedItem.name.includes("vent")) {
					let vent_direction = (selectedItem.name.includes("L") ? "L" : "R");
					console.log("vent placed + " + vent_direction);
					let vent = new steam_vent(selectedItem.name, "off", vent_direction);

					gridData[row][col] = vent; // Store the vent in the grid-cell
					return;
				}
				
				//placing steam spike
				if (selectedItem.name.includes("spike")) {
					console.log("spike placed ");
					let spike = new steam_spike(selectedItem.name, "off");
					spike.updateImg(row,col);
					gridData[row][col] = spike; // Store the spike in the grid-cell
					return;
				}
				
				
				//placing steam lamp
				if (selectedItem.name.includes("lamp")) {
					console.log("lamp placed ");
					let lamp = new steam_lamp(selectedItem.name, "off");
					gridData[row][col] = lamp; // Store the lamp in the grid-cell
					return;
				}
				
				

			}
			
			
		} 

			  

		//get data of blocks adjacent to input (row,col)
		
		let adjLatency = {}
		function adj(row, col) {
			let unique_1 = unique(20)
			
			adjLatency[unique_1] = function(){
				const adjacent = [];
				const rows = gridData.length;
				const cols = gridData[0].length;

				// Up
				let upBlock = row > 0 ? gridData[row - 1][col] || "null" : "null";
				if (upBlock !== "null" && upBlock.hasOwnProperty('name') && upBlock.name.includes("valve")) {
					adjacent.push(upBlock); // If vent is above, allow it
				} else {
					adjacent.push(upBlock); // Otherwise, behave as normal
				}

				// Down
				let downBlock = row < rows - 1 ? gridData[row + 1][col] || "null" : "null";
				if (downBlock !== "null" && downBlock.hasOwnProperty('name') && downBlock.name.includes("valve")) {
					adjacent.push(downBlock); // If vent is below, allow it
				} else {
					adjacent.push(downBlock); // Otherwise, behave as normal
				}

				// Left
				let leftBlock = col > 0 ? gridData[row][col - 1] || "null" : "null";
				if (leftBlock !== "null" && leftBlock.hasOwnProperty('name') && leftBlock.name.includes("valve")) {
					leftBlock = "null"; // If vent is on the left, treat it as null
				}
				adjacent.push(leftBlock);

				// Right
				let rightBlock = col < cols - 1 ? gridData[row][col + 1] || "null" : "null";
				if (rightBlock !== "null" && rightBlock.hasOwnProperty('name') && rightBlock.name.includes("valve")) {
					rightBlock = "null"; // If vent is on the right, treat it as null
				}
				adjacent.push(rightBlock);

				console.log(adjacent);
				return adjacent;
			}
			return adjLatency[unique_1]();
			
		}
		
		
		
		
		
		const arrow_mapper = {
			U:"âˆ§",
			D:"âˆ¨",
			L:"<",
			R:">"
		}
		
		
		let blockDatasLatency = {}
		function getBlockData(row,col){
			let unique_1 = unique(20)
			blockDatasLatency[unique_1] = function(){
				let cell = document.getElementById(`grid-cell-${row * 100 + col}`)
				let in_grid = gridData[row][col]
				return in_grid;
			}
			return blockDatasLatency[unique_1]()
		}	




		
		
		//unused template
		class general_steam_component {
			constructor(name){
				this.name = name;
			}
		}
		
		
		
		//steam engine class
		class steam_engine{
			constructor(name,active,interval){
				this.name = name;
				this.active = active;
				this.interval = interval;
			}
		}
		
		
		//steam spike class
		class steam_spike {
			constructor(name,state="off"){
				this.name = name;
				this.state = state;
			}
			
			toggleState(){
				this.state = this.state=="off"?"on":"off";
			}
			
			updateImg(row,col){
				changeBlockImage(row,col,this.getImage());
			}
			
			getImage(){
				return this.state=="on"?"assets/steam-spikes.png":"assets/steam-spikes-off.png"
			}
		}
		
			//steam launcher class
		class steam_launcher {
			constructor(name,state="off"){
				this.name = name;
				this.state = state;
			}
			
			toggleState(){
				this.state = this.state=="off"?"on":"off";
			}
			
			activate(){
				this.state = "on"
			}
			deactivate(){
				this.state = "off"
			}
			
			updateImg(row,col){
				let unique_1 = unique(15)
				let instance = this;
				change_image_all_functions[unique_1] = function(){	changeBlockImage(row,col,instance.getImage())}
				change_image_all_functions[unique_1]();
			
			}
			
			getImage(){
				return this.state=="on"?"assets/steam-launcher-on.png":"assets/steam-launcher.png"
			}
		}
		
		
		
		
		//steam vent class
		class steam_vent {
			constructor(name, state = "off", vent_direction) {
				this.name = name;
				this.state = state;
				this.vent_direction = vent_direction;
				this.timeout = null; // Keep track of the timeout
			}

			// Activate function to turn on the vent, wait, then turn it off
			activate(row, col) {
				// Always reset vent duration on activation
				console.log('vent activated, resetting duration');

				// Turn the vent "on"
				this.state = "on";
				let instance = this;
				let unique_1 = unique(20)
				change_image_all_functions[unique_1] = function(){ changeBlockImage(row, col, "assets/steam-vent-" + instance.vent_direction + "-on.png")}
				change_image_all_functions[unique_1]()

				// Clear any existing timeout to avoid multiple overlapping timeouts
				if (this.timeout) {
					clearTimeout(this.timeout);
					console.log('previous vent timeout cleared');
				}

				// Set a new timeout to turn off the vent after the specified duration
				this.timeout = setTimeout(() => {
					this.state = "off";
					let instance = this;
					let unique_1 = unique(20)
					change_image_all_functions[unique_1] = function(){ changeBlockImage(row, col, "assets/steam-vent-" + instance.vent_direction + ".png")}
					change_image_all_functions[unique_1]()
					console.log('vent off');
					this.timeout = null; // Reset the timeout variable
				}, global_vent_max_duration); // Use the global vent duration
			}
		}
		
		
		
		class steam_lamp{
			constructor(name, state = "off") {
				this.name = name;
				this.state = state;
				this.timeout = null; // Keep track of the timeout
			}

			// Activate function to turn on the lamp, wait, then turn it off
			activate(row, col) {
				console.log('lamp activated, resetting duration');

				// Turn the lamp "on"
				this.state = "on";
				let unique_1 = unique(15)
				change_image_all_functions[unique_1] = function(){ 	changeBlockImage(row, col, "assets/steam-lamp-on.png") }
				change_image_all_functions[unique_1]()
			

				// Clear any existing timeout to avoid multiple overlapping timeouts
				if (this.timeout) {
					clearTimeout(this.timeout);
					console.log('previous lamp timeout cleared');
				}

				// Set a new timeout to turn off the lamp after the specified duration
				this.timeout = setTimeout(() => {
					this.state = "off";
					let unique_1 = unique(15)
					change_image_all_functions[unique_1] = function(){ changeBlockImage(row, col, "assets/steam-lamp.png") };
					change_image_all_functions[unique_1]()
					console.log('lamp off');
					this.timeout = null; // Reset the timeout variable
				}, global_lamp_max_duration); // Use the global lamp duration
			}
		}
		
		
		
		
		//steam collector class (work in progress)
		class Steam_Collector {
			constructor(name, puffs=[]){
				this.name = name;
				this.puffs = puffs;
			}
		}
		
		
		//steam organ class
		class Steam_Organ {
			constructor(name,state="off",audio=global_organ_frequency){
				this.name = name;
				this.audio = audio;
				this.state = state;
				this.timeout = null;
			}
			
			activate(row, col) {
				console.log('organ activated, resetting duration');
				
				this.state = "on";
				changeBlockImage(row, col, "assets/steam-organ-on.png") 
				
				
				playTone(this.audio, global_organ_max_duration/1000) 

				// Clear any existing timeout to avoid multiple overlapping timeouts
				if (this.timeout) {
					clearTimeout(this.timeout);
					console.log('previous vent timeout cleared');
				}

				// Set a new timeout to turn off the organ after the specified duration
				this.timeout = setTimeout(() => {
					this.state = "off";
			     	changeBlockImage(row, col, "assets/steam-organ.png")
					console.log('organ off');
					this.timeout = null; 
				}, global_organ_max_duration); 
			}
			
		}

		
		
		
		
		
		//steam door class
		class steam_door {
			constructor(name, state="closed", row, col) {
				this.name = name;
				this.state = state;
				this.row = row;
				this.col = col;
			}

			toggleState() {
				this.state = this.state === "closed" ? "open" : "closed";
			}

			getImage() {
				return this.state === "closed" ? "assets/steam-door.png" : "assets/steam-door-open.png";
			}
			updateImg(row,col){
				changeBlockImage(row,col,this.getImage()) 
			}
		}

		
		
		
		// steam crank class
		class steam_crank {
			constructor(name, flow = "vertical") {
				this.name = name;
				this.flow = flow;
			}

			toggleFlow() {
				if (this.flow === "vertical") {
					this.flow = "horizontal";
				} else {
					this.flow = "vertical";
				}
			}
			
			// Method to update the crank image on the grid
			updateImg(row, col) {
				changeBlockImage(row, col, this.getImage()) // Update image based on flow state
				console.log("flow:"+this.flow+" "+this.getImage())
			}

			getImage() {
				return this.flow === "vertical" ? 'assets/steam-crank.png' : 'assets/steam-crank-horizontal.png';
			}
		}


		
		
		//steam valve class
		class steam_valve {
			constructor(name,orientation){
				this.name = name;
				this.orientation = orientation;
			}
			switch_orientation(){
				if(this.orientation == "L"){
					this.orientation = "R";
					console.log("new orientation:"+this.orientation)
				}
				else if(this.orientation == "R"){
					this.orientation = "L";
					console.log("new orientation:"+this.orientation)
				}
			}
			getImage() {
				return this.orientation === "L" ? 'assets/steam-valve-left.png' : 'assets/steam-valve-right.png';
			}
			
			updateImg(row,col){
				changeBlockImage(row,col,this.getImage()) 		
			}
		}




		//steam puff mechanics
		let Steam_Puffs = []
		const id_length = 5;
		
		
		class Puff {
			constructor(current_direction,position={row:null,col:null},distance_moved=0,collector_max_duration=global_collector_max_duration,unique_id,foundSpot = false,ele=null){
				this.current_direction = current_direction;
				this.position = position
				this.unique_id = unique(id_length);
				this.distance_moved = distance_moved;
				this.collector_max_duration = collector_max_duration;
				this.generate_puff(this.position.row,this.position.col)	
				this.foundSpot = foundSpot;
				this.ele = ele;		
				this.true_puff_speed = global_true_puff_speed;
				this.puff_speed = this.true_puff_speed
			}
			
			//generate a new steam puff visually
			generate_puff(row,col){
				 let cell = document.getElementById(`grid-cell-${ parseInt(this.position.row) * 100 + parseInt(this.position.col)}`);
			     if (cell) {
					// Create and display a new steam puff element
					const puffElement = document.createElement('div');
					puffElement.id = "puff-" + this.unique_id
					puffElement.innerHTML = this.current_direction
					puffElement.style.opacity = 0.7
					puffElement.classList.add('steam-puff');
					puffElement.style.top = '0px'; 
					puffElement.style.left = '0px'; 
					this.distance_moved+=1
					this.ele = puffElement;
					Steam_Puffs.push(this);
					cell.appendChild(puffElement)
					setTimeout(()=>{this.recursive_move()},this.puff_speed)
				 }
	 
		}
		
		
		
		//method to kill puff
		kill_puff(){	
		try{
				console.log(document.getElementById("puff-" + this.unique_id))
				document.getElementById("puff-" + this.unique_id).remove();
				Steam_Puffs.splice(Steam_Puffs.indexOf(Steam_Puffs.filter(a=>a.unique_id==this.unique_id)[0]),1);
				}
				catch(e){return}
				return;
		}
		
		//method to check if puff has found a spot to move to, if not kill the puff
		check_found_spot(){
			console.log('found spot:'+this.foundSpot)
			
			if(this.foundSpot == false){
					this.kill_puff();
					return;
				}
				
		}
		
		
		
		//recursive motion function
			recursive_move(){
			if(this.distance_moved >= this.max_puff_distance){
				this.kill_puff()
				return;
			}
			
			
			try{	
				this.foundSpot = false; 
				
				console.log('moved/max:'+this.distance_moved+"/"+max_puff_distance)
				if(this.distance_moved==max_puff_distance){
					//kill steam puff
					this.kill_puff()
					console.log("puff kill was attempted- max distance")
					return;
				}
			
				let adjCells = adj(this.position.row,this.position.col);
				
				//adjacent cells validity checks
				let ValidArr = {
				  U: adjCells[0] !== null && adjCells[0] !== undefined && adjCells[0].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[0].name) || adjCells[0].name.includes("funnel")), // up

				  D: adjCells[1] !== null && adjCells[1] !== undefined && adjCells[1].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[1].name) || adjCells[1].name.includes("funnel")), // down

				  L: adjCells[2] !== null && adjCells[2] !== undefined && adjCells[2].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[2].name) || adjCells[2].name.includes("funnel")), // left

				  R: adjCells[3] !== null && adjCells[3] !== undefined && adjCells[3].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[3].name) || adjCells[3].name.includes("funnel"))  // right
				};
				
				
				//currently in a steam door block
				if(gridData[this.position.row][this.position.col].name.includes("door")){
					//gridData[ this.position.row][ this.position.col].updateImg(this.position.row,this.position.col)
					gridData[this.position.row][this.position.col].toggleState();
					gridData[ this.position.row][ this.position.col].updateImg(this.position.row,this.position.col)
					let instance = this;
					setTimeout(function(){instance.kill_puff()},this.puff_speed)
					return;
				}
				
				
				//steam spike,launcher and lamp advanced move limiter
				if(adjCells[1]){
					if(adjCells[1].hasOwnProperty('name')){
						if(adjCells[1].name.includes("spike")||adjCells[1].name.includes("lamp")||adjCells[1].name.includes("launcher")){					
							ValidArr["D"] = null
							adjCells[1] = null
							console.log('limited')
						}
					}
				}
				
				if(adjCells[2]){
					if(adjCells[2].hasOwnProperty('name')){
						if(adjCells[2].name.includes("spike")||adjCells[2].name.includes("lamp")||adjCells[2].name.includes("launcher")){					
							ValidArr["L"] = null
							adjCells[2] = null
							console.log('limited')
						}
					}
				}
				
				if(adjCells[3]){
					if(adjCells[3].hasOwnProperty('name')){
						if(adjCells[3].name.includes("spike")||adjCells[3].name.includes("lamp")||adjCells[3].name.includes("launcher")){						
							ValidArr["R"] = null
							adjCells[3] =null
							console.log('limited')
						}
					}
				}
				
				
				//steam crank further limiter
				if(gridData[this.position.row][this.position.col]){
					if(gridData[this.position.row][this.position.col].hasOwnProperty('name')){
						if(gridData[this.position.row][this.position.col].name.includes('crank')){
							if(gridData[this.position.row][this.position.col].flow == "horizontal"){
								ValidArr["U"] = null
								adjCells[0] =null
								ValidArr["D"] = null
								adjCells[1] = null
								console.log('crank-limited')
							}
						}
					}
				}
				
				
				
				
				//if its currently at an organ, activate organ
				if(gridData[this.position.row][this.position.col].name.includes("organ")){
					console.log("currently in steam organ");
					gridData[this.position.row][this.position.col].activate(this.position.row,this.position.col);
				}
				
				
				
				//slow down speed if in steam collector
				if(gridData[this.position.row][this.position.col].name.includes("collector")){
					console.log("slowing puff down..."+ this.puff_speed);
					 this.puff_speed = collector_puff_speed;
				}
				else{
					//if not use regular speed
					console.log("puff_speed_reset"+  this.puff_speed);
					 this.puff_speed =  this.true_puff_speed;
				}
				
				
			
				
				
				//ULDR steam crossover handler
				if (gridData[this.position.row][this.position.col].name.includes("ULDR")) {
					console.log("Currently in ULDR crossover");

					// Check if adjacent cells are valid before changing direction
					if (this.current_direction == "U" && ValidArr["R"]) {
						this.changePosition("R", this.position.row, this.position.col+1);
					} else if (this.current_direction == "D" && ValidArr["L"]) {
						this.changePosition("L", this.position.row, this.position.col-1);
					} else if (this.current_direction == "L" && ValidArr["D"]) {
						this.changePosition("D", this.position.row+1, this.position.col);
					} else if (this.current_direction == "R" && ValidArr["U"]) {
						this.changePosition("U", this.position.row-1, this.position.col);
					} else {
						// If no valid move, kill the puff
						this.kill_puff();
					}

					this.check_found_spot();
					setTimeout(() => { this.recursive_move(); },  this.puff_speed);
					return;
				}
				
							
				// URDL steam crossover handler
				if (gridData[this.position.row][this.position.col].name.includes("URDL")) {
					console.log("Currently in URDL crossover");

					// Check if adjacent cells are valid before changing direction
					if (this.current_direction == "U" && ValidArr["L"]) {
						this.changePosition("L", this.position.row, this.position.col-1);
					} else if (this.current_direction == "D" && ValidArr["R"]) {
						this.changePosition("R", this.position.row, this.position.col+1);
					} else if (this.current_direction == "L" && ValidArr["U"]) {
						this.changePosition("U", this.position.row-1, this.position.col);
					} else if (this.current_direction == "R" && ValidArr["D"]) {
						this.changePosition("D", this.position.row+1, this.position.col);
					} else {
						// If no valid move, kill the puff
						this.kill_puff();
					}

					this.check_found_spot();
					setTimeout(() => { this.recursive_move(); },  this.puff_speed);
					return;
				}

				
				
				
				
				
			
				
					
				
				//prevent back flow of steam, note applies for collectors, collectors go below this
				if(this.current_direction=="U"){
				 if(!gridData[this.position.row][this.position.col].name.includes("funnel"))
				 ValidArr.D = null
				}
				if(this.current_direction=="D"){
					 if(!gridData[this.position.row][this.position.col].name.includes("funnel"))
				 ValidArr.U = null
				}
				if(this.current_direction=="L"){
					 if(!gridData[this.position.row][this.position.col].name.includes("funnel"))
				 ValidArr.R = null
				}
				if(this.current_direction=="R"){
					 if(!gridData[this.position.row][this.position.col].name.includes("funnel"))
				 ValidArr.L = null
				}
				
				
				if(adjCells[2]){
					if(adjCells[2].hasOwnProperty("name")&&adjCells[2].name.includes("vent")){
				    	adjCells[2] = null
						ValidArr["L"] = null						
					}
					}
					
					if(adjCells[3]){
					if(adjCells[3].hasOwnProperty("name")&&adjCells[3].name.includes("vent")){					
						adjCells[3] = null
						ValidArr["R"] = null
					}
					}
				
				
				
				
				//currently puff is in a valve block, handle movement from valve
				if(gridData[this.position.row][this.position.col].name.includes("valve")){
					console.log("valve encountered")
					let valve = gridData[this.position.row][this.position.col]
					
					
					//check if exit direction of valve leads to a valid block
					//check if standard valve behaviour is possible
					if(ValidArr[valve.orientation]!="null"&&ValidArr[valve.orientation]){
						//valve leads to valid block				
							console.log('valve attempt valid exit:'+valve.orientation);
							if(valve.orientation=="L"){
								this.changePosition("L",this.position.row,this.position.col)
								valve.switch_orientation();
								valve.updateImg(this.position.row,this.position.col)
								console.log("switched orientation:"+valve.orientation)
							}
							else if(valve.orientation=="R"){
								this.changePosition("R",this.position.row,this.position.col)
								valve.switch_orientation();
								valve.updateImg(this.position.row,this.position.col)
								console.log("switched orientation:"+valve.orientation)
							}							
					}
					
					//if standard behaviour is not possible, leads to invalid
					//go straight direction
					else{
						if(this.current_direction=="U"){
							if(ValidArr["U"]!="null"&&ValidArr["U"]){
								this.changePosition("U",this.position.row,this.position.col);
								}
								else{
									valve.switch_orientation()
									valve.updateImg(this.position.row,this.position.col)
									this.kill_puff()
									return;
									console.log("kill attempt"+this.current_direction)
								}
							}
							else if(this.current_direction=="D"){
						if(ValidArr["D"]!="null"&&ValidArr["D"]){
									this.changePosition("D",this.position.row,this.position.col);
									}
									else{
										valve.switch_orientation()
										valve.updateImg(this.position.row,this.position.col)
										this.kill_puff()
										return;
										console.log("kill attempt"+this.current_direction)
									}
							}
							else{
								this.kill_puff()
								console.log("kill attempt"+this.current_direction)
							}
						
							
						valve.switch_orientation();
						valve.updateImg(this.position.row,this.position.col)
						console.log("switched orientation:"+valve.orientation)
						
					}
					
					

					
					
					this.check_found_spot();
					//setTimeout(()=>{this.recursive_move()}, this.puff_speed)
					
				}
				
				
				
					
						
				//steam crank system to prevent motion to improper crank
				//obtaining current block infront of steam puff
				let adj_block = adj(this.position.row,this.position.col)
				let block;
				if(this.current_direction=="U"){
					block = adj_block[0]
				}
				if(this.current_direction=="D"){
					block = adj_block[1]
				}
				if(this.current_direction=="L"){
					block = adj_block[2]
				}
				if(this.current_direction=="R"){
					block = adj_block[3]
				}
				
				//steam crank system to prevent motion to improper crank
				if(block.hasOwnProperty("name")){
				if(block.name.includes("crank")){
					if(this.current_direction=="U"&&block.flow=="horizontal"){
						alert("v")
						ValidArr.U = null
					}
					if(this.current_direction=="D"&&block.flow=="horizontal"){
						ValidArr.D = null
					}
					if(this.current_direction=="L"&&block.flow=="vertical"){
						ValidArr.L = null
					}
					if(this.current_direction=="R"&&block.flow=="vertical"){
						ValidArr.R = null
					}
					
					
				}
				}
				
				
				if(adj_block[1]){
				if(adj_block[1].hasOwnProperty("flow")){			
						if(this.current_direction=="L"&&adj_block[1].flow=="horizontal"){
							ValidArr["D"] = null
							adj_block[1] = null
						}
						if(this.current_direction=="R"&&adj_block[1].flow=="horizontal"){
							ValidArr["D"] = null
							adj_block[1] = null
						}
					}
					}
					
				
				if(adjCells[0]){
				if(adjCells[0].hasOwnProperty("flow")){			
						if(this.current_direction=="L"&&adjCells[0].flow=="horizontal"){
							ValidArr["U"] = null
							adjCells[0] = null
						}
						if(this.current_direction=="R"&&adjCells[0].flow=="horizontal"){
							ValidArr["U"] = null
							adjCells[0] = null
						}
					}
				}
					
				
				if(adj_block[2]){
				if(adj_block[2].hasOwnProperty("flow")){			
						if(this.current_direction=="D"&&adj_block[2].flow=="vertical"){
							ValidArr["L"] = null
							adj_block[2] = null
						}
						if(this.current_direction=="U"&&adj_block[2].flow=="vertical"){
							ValidArr["L"] = null
							adj_block[2] = null
							
						}
					}
					}
				
				
				if(adj_block[3]){
				if(adj_block[3].hasOwnProperty("flow")){			
						if(this.current_direction=="D"&&adj_block[3].flow=="vertical"){
							ValidArr["R"] = null
							adj_block[3] = null
						}
						if(this.current_direction=="U"&&adj_block[3].flow=="vertical"){
							ValidArr["R"] = null
							adj_block[3] = null
						}
					}
				}
					
							
				
				//vent system (new)
				if (gridData[this.position.row][this.position.col].name.includes("vent")) {
				// Activate the vent
				gridData[this.position.row][this.position.col].activate(this.position.row, this.position.col);
					if(ValidArr[this.current_direction]==true){ 
					if(this.current_direction=="U")
						this.changePosition("U",this.position.row,this.position.col);
					if(this.current_direction=="D")
						this.changePosition("D",this.position.row,this.position.col);
					}
					else{
						this.kill_puff()
					}
				}
				
				
				
				//activate lamp and kill puff
				if (gridData[this.position.row][this.position.col].name.includes("lamp")) {
					// Activate the lamp
					gridData[this.position.row][this.position.col].activate(this.position.row, this.position.col);				
					let instance = this;
					setTimeout(function(){instance.kill_puff()},this.puff_speed)
					return;
				}
				
				//activate launcher and kill puff
				if (gridData[this.position.row][this.position.col].name.includes("launcher")) {
					// Activate the launcher
					gridData[this.position.row][this.position.col].activate();		
					gridData[this.position.row][this.position.col].updateImg(this.position.row,this.position.col)		
					let instance = this;
					setTimeout(function(){instance.kill_puff()},this.puff_speed)
					return;
				}
									
				
				//steam spike system activates spike and kills puff
				if(gridData[this.position.row][this.position.col].name.includes("spike")){		
					gridData[this.position.row][this.position.col].updateImg();
					gridData[this.position.row][this.position.col].toggleState();
					gridData[this.position.row][this.position.col].updateImg(this.position.row,this.position.col);
					let instance = this;
					setTimeout(function(){instance.kill_puff()},this.puff_speed)
					return;
				}
				



			



		
			//currently puff is in a funnel block, handle movement from funnel
				if(gridData[this.position.row][this.position.col].name.includes("funnel")){
					console.log('currently in funnel')
					
					if(gridData[this.position.row][this.position.col].name.includes("up")){
							console.log(ValidArr['U'])
							if(ValidArr['U']&&ValidArr['U']!='null'){
							console.log('up funnel')
							this.changePosition("U",this.position.row-1,this.position.col)
							}
							else{
								this.kill_puff()
								return
							}
					
						
					}
					else if(gridData[this.position.row][this.position.col].name.includes("down")){
							console.log(ValidArr['D'])
							if(ValidArr['D']&&ValidArr['D']!='null'){
							console.log('down funnel')
							this.changePosition("D",this.position.row+1,this.position.col)
							}
							else{
								this.kill_puff()
								return
							}
						
					}
					else if(gridData[this.position.row][this.position.col].name.includes("left")){
						if(ValidArr['L']&&ValidArr['L']!='null'){
							console.log('left funnel')
							this.changePosition("L",this.position.row,this.position.col-1)
							}
							else{
								this.kill_puff()
								return
							}
						
					}
					else if(gridData[this.position.row][this.position.col].name.includes("right")){
					if(ValidArr['R']&&ValidArr['R']!='null'){
							console.log('right funnel')
							this.changePosition("R",this.position.row,this.position.col+1)
						}
						else{
								this.kill_puff()
								return
							}
						
					}
					
					
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				   return;
				}
				
				
				
			




			//PRIMATIVE SYSTEM BELOW THIS LINE
			
			
				console.log("BLOCK:"+gridData[this.position.row][this.position.col].name+" -Valid Array:"+Object.values(ValidArr))
				
				//steam scrambler system
				if(gridData[this.position.row][this.position.col].name.includes('scrambler')){
					console.log('steam scrambler system active')
					
					let possibleKeys = Object.keys(ValidArr).filter(key => 
					  ValidArr[key] != null && ValidArr[key] != 'null' && ValidArr[key] != false
					);
					
					//srcambler cant proceed anywhere, kill puff
					if(possibleKeys.length==0){
						console.log('scrambler cant proceed, kill puff')
						this.kill_puff();
						return;
					}
					
					
					console.log('possible spot count: '+possibleKeys.length);
					
					let randomKey = possibleKeys[Math.floor(Math.random() * possibleKeys.length)]
					console.log('selected output: '+ randomKey)
					this.changePosition(randomKey,this.position.row,this.position.col)
				}
			
			
			
			
			
		// steam collector system
if (gridData[this.position.row][this.position.col].name.includes('collector')) {
    let possibleKeys = Object.keys(ValidArr).filter(key => 
        ValidArr[key] != null && ValidArr[key] != 'null' && ValidArr[key] != false
    );

    if (possibleKeys.length >= 2) {
        let current_collector = gridData[this.position.row][this.position.col];
        
        // If the puff is not already in the collector, add it, but don't add `this` puff again
        if (current_collector.puffs.filter(puff => puff.unique_id == this.unique_id).length == 0) {
            current_collector.puffs.push(this);

            // Set a 20-second timer to kill and remove the puff if it stays too long
            this.timeoutId = setTimeout(() => {
                // Kill the puff if it exceeds 20 seconds in the collector
                current_collector.puffs = current_collector.puffs.filter(p => p.unique_id !== this.unique_id);
                console.log(`Puff ${this.unique_id} killed after 20 seconds in the collector.`);
                this.kill_puff(); // Kill the puff
            }, global_collector_max_duration); // 20 seconds timeout
        }

        console.log('collector puff count: ' + current_collector.puffs.length);

        // If the number of valid directions equals the number of stored puffs, release them
        if (possibleKeys.length == current_collector.puffs.length) {
            console.log('releasing steam puffs from collector...');

            // Only release and move puffs that are already stored in the collector (excluding `this`)
            current_collector.puffs.forEach((puff, index) => {
                clearTimeout(puff.timeoutId);  // Clear timeout for released puff

                if (puff.unique_id !== this.unique_id) {  // Make sure not to move `this` puff here
                    let direction = possibleKeys[index];
                    if (direction == "U")
                        puff.changePosition("U", puff.position.row - 1, puff.position.col);
                    if (direction == "D")
                        puff.changePosition("D", puff.position.row + 1, puff.position.col);
                    if (direction == "L")
                        puff.changePosition("L", puff.position.row, puff.position.col - 1);
                    if (direction == "R")
                        puff.changePosition("R", puff.position.row, puff.position.col + 1);

                    // Continue moving the puff recursively
                    setTimeout(() => { puff.recursive_move(); }, puff.puff_speed);
                }

                if (puff.unique_id == this.unique_id) {  // Make sure not to move `this` puff here
                    let direction = possibleKeys[index];
                    if (direction == "U")
                        puff.changePosition("U", puff.position.row, puff.position.col);
                    if (direction == "D")
                        puff.changePosition("D", puff.position.row, puff.position.col);
                    if (direction == "L")
                        puff.changePosition("L", puff.position.row, puff.position.col);
                    if (direction == "R")
                        puff.changePosition("R", puff.position.row, puff.position.col);

                    // Continue moving the puff recursively
                    setTimeout(() => { puff.recursive_move(); },  puff.puff_speed);
                }
            });

            // Clear the stored puffs after releasing them
            current_collector.puffs = [];
        } else {
            // Wait for more puffs if not all are ready
            return;
        }
    }
}








		
			


				
				
				//standard straight motion system
				if(ValidArr[this.current_direction]==true){ //can move straight
					console.log("straight line motion");
					if(this.current_direction=="U")
						this.changePosition("U",this.position.row-1,this.position.col);
					if(this.current_direction=="D")
						this.changePosition("D",this.position.row+1,this.position.col);
					if(this.current_direction=="L")
						this.changePosition("L",this.position.row,this.position.col-1);
					if(this.current_direction=="R")
						this.changePosition("R",this.position.row,this.position.col+1);
					
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				
				//right movement puff logic
				else if(this.current_direction=="U" && ValidArr["R"] ){
					this.changePosition("R",this.position.row,this.position.col+1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				else if(this.current_direction=="D" && ValidArr["L"] ){
					this.changePosition("L",this.position.row,this.position.col-1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				else if(this.current_direction=="L" && ValidArr["U"] ){
					this.changePosition("U",this.position.row-1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				else if(this.current_direction=="R" && ValidArr["D"] ){
					this.changePosition("D",this.position.row+1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				
				//left movement puff logic
				else if(this.current_direction=="U" && ValidArr["L"] ){
					this.changePosition("L",this.position.row,this.position.col-1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				else if(this.current_direction=="D" && ValidArr["R"] ){
					this.changePosition("R",this.position.row,this.position.col+1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				else if(this.current_direction=="L" && ValidArr["D"] ){
					this.changePosition("D",this.position.row+1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				else if(this.current_direction=="R" && ValidArr["U"] ){
					this.changePosition("U",this.position.row-1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
					}catch(e){console.log(e)}
				this.check_found_spot();
			
			}
			
			
			//change puff position in grid
				changePosition(newDirection, newRow, newCol) {
				// Get the current cell and new cell in the grid
				const currentCell = document.getElementById(`grid-cell-${this.position.row * 100 + this.position.col}`);
				const newCellIndex = newRow * 100 + newCol;
				const newCell = document.getElementById(`grid-cell-${newCellIndex}`);

				// Find the puff element in the current cell
				const puffElement = document.getElementById(`puff-${this.unique_id}`);
				if (puffElement) {
					// Remove puff element from the current cell
					if (currentCell) {
						currentCell.removeChild(puffElement);
					}

					// Append puff element to the new cell
					if (newCell) {
						puffElement.style.top = "0px"
						puffElement.style.left = "0px"
						this.current_direction = newDirection;
						//increment distance moved
						this.distance_moved += 1;
						let scaledValue = Math.round((this.distance_moved / 99) * 255); // Scale distance to 1-255 range
						puffElement.style.backgroundColor = "rgb(" + scaledValue + "," + (255 - scaledValue) + ",90)";
						puffElement.innerHTML = this.distance_moved + "-"+this.current_direction

						this.foundSpot = true;
						newCell.appendChild(puffElement);
					}

					// Update puff's position
					this.position = {row:newRow, col:newCol};
				}
			}

		}

		
		
		
		
		let activator_queue = {}
		
		
		
		 //used for revolver
		 function steamSystem_main(act_r, act_c) {        
			let unique_1 = unique(20);
			
			activator_queue[unique_1] = function(){
            console.log(gridData);
            const adjCells = adj(act_r, act_c);
			
			//additional check for spike/lamp/launcher below
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('spike')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('lamp')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('launcher')){
					adjCells[1] = null
				}
			}
			
			//more sus crank checks
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('crank')){
				if(adjCells[1].flow=="horizontal")
					adjCells[1] = null
				}
			}
			if(adjCells[0]){
				if(adjCells[0].hasOwnProperty('name')&&adjCells[0].name.includes('crank')){
				if(adjCells[0].flow=="horizontal")
					adjCells[0] = null
				}
			}

            
            adjCells.forEach((cell, index) => {
			if(cell)
                console.log(`Adjacent ${index}: ${cell === "null" ? "null" : cell.name}`);
            });

			  if (
			  adjCells[0] !== null && adjCells[0] !== undefined && 
			  adjCells[0].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[0].name) || 
				adjCells[0].name.includes("funnel")
			  )
			) {
	
			  //spawn puff up
			  let _puff = new Puff("U", { row: act_r - 1, col: act_c });
			} 
			else if (
			  adjCells[1] !== null && adjCells[1] !== undefined && 
			  adjCells[1].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[1].name) || 
				adjCells[1].name.includes("funnel")
			  )
			) {
		
			  //spawn puff down
			  let _puff = new Puff("D", { row: act_r + 1, col: act_c });
			} 
			else {
			  //nowhere to propagate to
			}

		}
		activator_queue[unique_1]()

        }
			

		//used for stomper
       function steamSystem_main2(act_r, act_c, provider="") {
			console.log(gridData);
			
			let adjCells = adj(act_r, act_c); // Get adjacent cells
			
			//additional check for spike/lamp below
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('spike')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('lamp')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('launcher')){
					adjCells[1] = null
				}
			}
						
			//more sus crank checks
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('crank')){
				if(adjCells[1].flow=="horizontal")
					adjCells[1] = null
				}
			}
			if(adjCells[0]){
				if(adjCells[0].hasOwnProperty('name')&&adjCells[0].name.includes('crank')){
				if(adjCells[0].flow=="horizontal")
					adjCells[0] = null
				}
			}


			// Function to check if a cell is valid
			function isValidCell(cell) {
				return cell !== null && cell !== undefined && cell.hasOwnProperty('name');
			}

			// Function to check if propagation should occur
			function shouldPropagate(cell) {
				return standard_behaviour.includes(cell.name) || cell.name.includes("funnel");
			}

			// Function to handle puff propagation
			function handlePuff(direction, newRow, newCol) {
				let _puff = new Puff(direction, { row: newRow, col: newCol });
			}

			// Check and handle "sus crank" for a specific cell
			function checkSusCrank(row, col, directionIndex) {
				const cell = gridData[row][col];
				if (cell.name.includes("crank") && cell.flow === "horizontal") {
					console.log("Caught sus crank, treating as null");
					adjCells[directionIndex] = null; // Treat this cell as null
					return true; // Crank detected
				}
				return false; // No crank detected
			}

			// Main propagation logic
			function propagate() {
			console.log(provider)
				if (isValidCell(adjCells[0]) && shouldPropagate(adjCells[0])&&!provider=="steam stomper") {
				console.log(provider)
					// Check for sus crank and treat as null if found
					if (checkSusCrank(act_r - 1, act_c, 0)) {
						propagate(); // Retry after marking crank as null
						return;
					}
					// Move up
					handlePuff("U", act_r - 1, act_c);
				} 
				else if (isValidCell(adjCells[1]) && shouldPropagate(adjCells[1])) {
					// Check for sus crank and treat as null if found
					if (checkSusCrank(act_r + 1, act_c, 1)) {
						propagate(); // Retry after marking crank as null
						return;
					}
					// Move down
					handlePuff("D", act_r + 1, act_c);
				} 
				else {
					// No valid direction to propagate to
					console.log("No valid direction for puff propagation");
				}
			}

			// Initial propagation attempt
			propagate();
		}

	
	
	
	
	
	
	
	
	
	
	
	
	//for engines
	 function steamSystem_main3(act_r, act_c) {        
			let unique_1 = unique(20);
			
			activator_queue[unique_1] = function(){
            console.log(gridData);
            const adjCells = adj(act_r, act_c);
			
			//additional check for spike/lamp/launcher below
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('spike')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('lamp')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('launcher')){
					adjCells[1] = null
				}
			}
			
			//more sus crank checks
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('crank')){
				if(adjCells[1].flow=="horizontal")
					adjCells[1] = null
				}
			}
			if(adjCells[0]){
				if(adjCells[0].hasOwnProperty('name')&&adjCells[0].name.includes('crank')){
				if(adjCells[0].flow=="horizontal")
					adjCells[0] = null
				}
			}
			
			//additonal for engine
			const checkAndNullify = (cell) => {
				if (cell && cell.hasOwnProperty('name')) {
					if ((cell.name.includes('valve') || cell.name.includes('vent'))) {
						return null;
					}
					if ((cell.name.includes('spike') || cell.name.includes('lamp')|| cell.name.includes('launcher'))) {
						return null;
					}
					if(cell.hasOwnProperty('flow')&&cell.flow=="vertical")
						return null;
				}
				return cell;
			};
			adjCells[2] = checkAndNullify(adjCells[2]);
			adjCells[3] = checkAndNullify(adjCells[3]);


            
            adjCells.forEach((cell, index) => {
			if(cell)
                console.log(`Adjacent ${index}: ${cell === "null" ? "null" : cell.name}`);
            });
			
			  if (
			  adjCells[3] !== null && adjCells[3] !== undefined && 
			  adjCells[3].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[3].name) || 
				adjCells[3].name.includes("funnel")
			  )
			){
				//spawn puff right
			  let _puff = new Puff("R", { row: act_r, col: act_c +1});
			} 

			  else if (
			  adjCells[0] !== null && adjCells[0] !== undefined && 
			  adjCells[0].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[0].name) || 
				adjCells[0].name.includes("funnel")
			  )
			) {
	
			  //spawn puff up
			  let _puff = new Puff("U", { row: act_r - 1, col: act_c });
			} 
			else if (
			  adjCells[1] !== null && adjCells[1] !== undefined && 
			  adjCells[1].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[1].name) || 
				adjCells[1].name.includes("funnel")
			  )
			) {
		
			  //spawn puff down
			  let _puff = new Puff("D", { row: act_r + 1, col: act_c });
			} 
			else {
			  //nowhere to propagate to
			}

		}
		activator_queue[unique_1]()

        }
		
		
		
		//left engine
		function steamSystem_main4(act_r, act_c) {        
			let unique_1 = unique(20);
			
			activator_queue[unique_1] = function(){
            console.log(gridData);
            const adjCells = adj(act_r, act_c);
			
			//additional check for spike/lamp/launcher below
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('spike')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('lamp')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('launcher')){
					adjCells[1] = null
				}
			}
			
			//more sus crank checks
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('crank')){
				if(adjCells[1].flow=="horizontal")
					adjCells[1] = null
				}
			}
			if(adjCells[0]){
				if(adjCells[0].hasOwnProperty('name')&&adjCells[0].name.includes('crank')){
				if(adjCells[0].flow=="horizontal")
					adjCells[0] = null
				}
			}
			
			//additonal for engine
			const checkAndNullify = (cell) => {
				if (cell && cell.hasOwnProperty('name')) {
					if ((cell.name.includes('valve') || cell.name.includes('vent'))) {
						return null;
					}
					if ((cell.name.includes('spike') || cell.name.includes('lamp')|| cell.name.includes('launcher'))) {
						return null;
					}
					if(cell.hasOwnProperty('flow')&&cell.flow=="vertical")
						return null;
				}
				return cell;
			};
			adjCells[2] = checkAndNullify(adjCells[2]);
			adjCells[3] = checkAndNullify(adjCells[3]);


            
            adjCells.forEach((cell, index) => {
			if(cell)
                console.log(`Adjacent ${index}: ${cell === "null" ? "null" : cell.name}`);
            });
			
			  if (
			  adjCells[2] !== null && adjCells[2] !== undefined && 
			  adjCells[2].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[2].name) || 
				adjCells[2].name.includes("funnel")
			  )
			){
				//spawn puff left
			  let _puff = new Puff("L", { row: act_r, col: act_c -1});
			} 

			  else if (
			  adjCells[0] !== null && adjCells[0] !== undefined && 
			  adjCells[0].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[0].name) || 
				adjCells[0].name.includes("funnel")
			  )
			) {
	
			  //spawn puff up
			  let _puff = new Puff("U", { row: act_r - 1, col: act_c });
			} 
			else if (
			  adjCells[1] !== null && adjCells[1] !== undefined && 
			  adjCells[1].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[1].name) || 
				adjCells[1].name.includes("funnel")
			  )
			) {
		
			  //spawn puff down
			  let _puff = new Puff("D", { row: act_r + 1, col: act_c });
			} 
			else {
			  //nowhere to propagate to
			}

		}
		activator_queue[unique_1]()

        }
</script>
</body>
</html>
