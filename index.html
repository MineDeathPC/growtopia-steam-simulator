<!DOCTYPE html>
<!--This program was created by MineDeath, Instagram: minedeath.gt-->
<!--Growtopia is licensed by Ubisoft, I do not own the game or its assets in any way-->




<html>
<head>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
<link rel="manifest" href="manifest.json">
<link rel="stylesheet" href="main.css">

 <title>Steam Simulator</title>
    <!--ustom PNG favicon -->
    <link rel="icon" type="image/png" href="assets/steam-tubes.png">
<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1"/>

</head>

<body>
  <div class="orientation-message"style="font-size:0.45cm;font-family: 'Roboto Mono', monospace;color:white;position:absolute;left:50%;top:10%;transform:translate(-50%,10%);">
        Please rotate your device...
		<br /><br /><br /><br />
		<img src="assets/rotate.png"></img>
    </div>
	
	  <div class="content">
    <div id="inv-cont">
        <div id="inv"></div>
    </div>
	

    <div id="grid"></div>
	
	<div id="top-bar"></div>
   

    <!-- Hint text for showing inventory -->
    <button id="toggle-hint" onclick="toggleInventory()">Tap or press I to open/close Inventory</button>
	<h3 id="puff-counter" title="how many active steam puffs are present">Active steam puff count: 0</h3>
	<button id="block-counter-button" onclick="toggleBlockCount()" title="how many blocks of each type are present on the grid">view block count</button>
	<div id="block-count-display"><h2>block count [BETA]: </h2><br /><br /> </div>

    <!-- Toggle Grid Button -->
    <button id="show_grid_button" alt="toggle grid" onclick="mobileToggle()">Hide Grid (G)</button>
	
	 
     <button id="save_build_button" onclick="saveBuild()">Save Build</button>
	 <button id="load_build_button" onclick="loadBuild()">Load Build</button>
	 <button id="reset_grid_button" onclick="resetGrid_button()">Reset Grid</button>
	 <button id="load_example_build_button" style="display:none;">Load Examples</button>
    <div id="example-builds-container" style="display:none; position:fixed; width:50%; height:50%; z-index:15; top:50%; left:50%; transform:translate(-50%, -50%); padding:20px; background:white; border:1px solid 	#ccc; box-shadow:0px 0px 10px rgba(0, 0, 0, 0.1);"></div>
	
	
<div class="fixed-text">Created By: <i style="color:rgb(255, 195, 30);"><b>MineDeath </b></i></div>
	
<!-- end of all content-->
</div>
<input type="file" id="file-input" style="display:none;" onchange="loadFile(event)"/>
<!-- wait for body to fully load-->
<script src = "sweetalert.js"></script>
<script src = "index.js"></script>
<script>



	//important constants
		const global_true_puff_speed = 99 //0.1s default
		const collector_puff_speed = 300;//0.3s (default)
		const max_puff_distance = 100;//99+1 (based on game)
		const global_collector_max_duration = 20000; //20s, 20000ms (based on game)
		const global_vent_max_duration = 3000 //3 sec (based on game)
		const global_organ_max_duration = 110; 
		const global_organ_frequency = 500;
		const global_lamp_max_duration = 10000; //10s, 10000ms (based on game)
		const global_engine_interval = 3000; //3s, 3000ms (based on game)
		const block_shadow_style = "drop-shadow(3.5px 3.5px 1.5px rgba(0, 0, 0, 0.7))"; //5px 2px 2px rgba(0, 0, 0, 0.7)
									//horizontal, vertical, blur
		



//loading and saving system
function saveBuild2(){swal("404","not implemented yet, sorry!","error")}
function loadBuild2(){swal("404","not implemented yet, sorry!","error")}


//min,max are inclusive
function randomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

	function unique(length) {
		let result = '';
		const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
		const charactersLength = characters.length;
		let counter = 0;
		while (counter < length) {
		  result += characters.charAt(Math.floor(Math.random() * charactersLength));
		  counter += 1;
		}
		
	//	console.log(result)
		return result;
	}



let selectedItem = null


const itemsWithState = ["steam crank", "steam door"];

// Function to extract the specific state based on the block type
function getBlockState(block) {
    if (!block) return null;

    // Handle specific blocks that retain different types of state
    if (block.name === "steam crank") {
		console.log("saved+"+block.flow)
        return block.flow; // Return the flow state for cranks
    } else if (block.name === "steam door") {
		console.log("saved+"+block.state)
        return block.state; // Return the door state for doors (e.g., "open" or "closed")
    } else {
        return null; // No state to save for other blocks
    }
}

// Save build function
// Save build function
function saveBuild() {
    swal("BETA", "Saving and loading builds is still in beta development, expect bugs!", "warning");
    
    const simplifiedGridData = gridData.map(row => 
        row.map(block => {
            if (block&&block!='null') {
                if (itemsWithState.includes(block.name)) {
                    console.log("saved++" + getBlockState(block));
                    return { name: block.name, state: getBlockState(block) }; // Save both name and specific state
                } else {
                    return { name: block.name }; // Save only the name for other blocks
                }
            } else {
                return null; // Use the string "null" for empty slots
            }
        })
    );

    const blob = new Blob([JSON.stringify(simplifiedGridData)], { type: "application/json" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "steam_simulator_build.json";
    link.click();
	console.log('build saved!')
}

// Load build function
// Load build function
function loadBuild() {
    swal("BETA", "Saving and loading builds is still in beta development, expect bugs!", "warning");
    document.getElementById('file-input').click(); // Trigger file input
}

// Load build function
function loadFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        const content = e.target.result;
        try {
            const loadedGridData = JSON.parse(content);
            resetGrid(); // Clear the existing grid before loading

            // Apply loaded data to the grid
            loadedGridData.forEach((row, rowIndex) => {
                row.forEach((blockData, colIndex) => {
                    if (blockData == "null") {
                        blockData = null; // Convert "null" string to null
                    }
                    if (blockData!=null&&blockData!="null") {
                        selectedItem = { name: blockData.name, orientation: 0 }; // Reset orientation by default
                        
                        // Check if the block has a saved state and restore it
                        if (blockData.state) {
                            restoreBlockState(blockData, blockData.state, rowIndex, colIndex); // Restore the specific state and update image
                        }

                        // Use the existing placeBlock function for placing the block
                        placeBlock(document.getElementById(`grid-cell-${rowIndex * 100 + colIndex}`), rowIndex * 100 + colIndex);
                    }
                });
            });
        } catch (err) {
            alert("Failed to load build. Invalid file format.");
            console.error("Error loading file:", err);
        }
    };
    reader.readAsText(file);
	console.log('build loaded!')
}



// Function to restore the specific block state during loading
function restoreBlockState(block, state,row=null,col=null) {
setTimeout(()=>{
    if (!block) return;

    if (block.name === "steam crank") {
        gridData[row][col].flow = state; // Set the flow state directly
        gridData[row][col].updateImg(row,col); // Update the crank image based on the restored flow
    } else if (block.name === "steam door") {
         gridData[row][col].state = state; // Set the door state directly
          gridData[row][col].updateImg(row,col); // Update the door image based on state
    }
	},1000)
}


// Function to reset the grid visually and in gridData
function resetGrid_button() {
	swal({
		title: "Are you sure?",
		text: "The grid will be cleared!",
		icon: "warning",
		buttons: true,
		dangerMode: true,
	}).then((result)=>{
		if(!result)
			return;

		for (let i = 0; i < 10000; i++) {
			const cell = document.getElementById(`grid-cell-${i}`);
			if (cell) {
				cell.innerHTML = '';
				cell.style.border = '2px groove rgba(0, 230, 230, 0.4)';
				cell.style.filter = ''
				let existingButton = document.getElementById(`activator-${i}`);
					if (existingButton) {
						document.body.removeChild(existingButton);
						existingButton.remove()
					}
			}
		
		}
		//kill all steam puffs
		Steam_Puffs.forEach((puff)=>{
			puff.kill_puff()
			console.log('killed a steam puff!')
		})
		Steam_Puffs = []

		// Reset gridData
		gridData = Array.from({ length: 100 }, () => Array(100).fill(null)); 
	})
}


//same as above but without warning
function resetGrid() {
		for (let i = 0; i < 10000; i++) {
			const cell = document.getElementById(`grid-cell-${i}`);
			if (cell) {
				cell.innerHTML = '';
				cell.style.border = '2px groove rgba(0, 230, 230, 0.4)';
				cell.style.filter = ''
				let existingButton = document.getElementById(`activator-${i}`);
					if (existingButton) {
						document.body.removeChild(existingButton);
						existingButton.remove()
					}
			}
		
		}

		//kill all steam puffs
		Steam_Puffs.forEach((puff)=>{
			puff.kill_puff()
			console.log('killed a steam puff!')
		})
		Steam_Puffs = []

		// Reset gridData
		gridData = Array.from({ length: 100 }, () => Array(100).fill(null)); 
}





		//audio controls
		
		// Create an AudioContext		
		let audioContext = null;
		document.body.onclick = function(){
		if(audioContext)
			return;
		audioContext = new (window.AudioContext || window.webkitAudioContext)()
		};

		// Function to play a tone
		function playTone(frequency, duration) {
			const oscillator = audioContext.createOscillator();
			oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
			oscillator.type = 'sine';
			oscillator.connect(audioContext.destination);
			oscillator.start();
			oscillator.stop(audioContext.currentTime + duration);
		}

		

	
		let grid_view_toggle = false;

		function showGridBorder() {
			Array.from(document.getElementsByClassName("grid-cell")).forEach((e)=>{
				e.style.border = "2px groove rgba(0,0,0,0)"
				document.getElementById('show_grid_button').innerHTML = "Show Grid (G)"
				document.getElementById('show_grid_button').style.backgroundColor = "indigo"
			})
		}

		function hideGridBorder() {
		Array.from(document.getElementsByClassName("grid-cell")).forEach((e)=>{
			 e.style.border = "2px groove rgba(0,230,230,0.4)"
			 document.getElementById('show_grid_button').innerHTML = "Hide Grid (G)"
			 document.getElementById('show_grid_button').style.backgroundColor = "violet"
			 })
		}




		
		
		
		
		
		//toggle grid for mobile
		function mobileToggle(){
		grid_view_toggle = !grid_view_toggle;
				if (grid_view_toggle) {
					showGridBorder()
					
				} else {
					hideGridBorder()
				
				}
		}
	
	
	

		//show block count function NEW
		showingBlockCount = false;

		showingBlockCount = false;

function toggleBlockCount() {
    let count_display = document.getElementById("block-count-display");
    
    if (!showingBlockCount) {
        let filteredData = gridData.flat().filter(a => a && a.hasOwnProperty("name"));
        let steamPipeCount = 0; // To hold the total count of steam pipes
        let min_1 = false;

        // List of pipe names
        const pipeNames = [
            'steam pipe',
            'pipe-vertical',
            'pipe-horizontal',
            'pipe-4-junction',
            'pipe-3-junction-L',
            'pipe-3-junction-R',
            'pipe-3-junction-U',
            'pipe-3-junction-D',
            'pipe-corner-DL',
            'pipe-corner-DR',
            'pipe-corner-UL',
            'pipe-corner-UR'
        ];

        // Count the pipes
        pipeNames.forEach(itemName => {
            const count = filteredData.filter(a => a.name === itemName).length;
            steamPipeCount += count; // Aggregate count for steam pipes
        });

        // Display the aggregated count for steam pipes
        if (steamPipeCount > 0) {
            count_display.innerHTML += "<b>steam pipes: " + steamPipeCount + "</b><br />";
            min_1 = true; // Set min_1 to true if there are steam pipes
        }

        // Count and display other items
        items.forEach(item => {
            const count = filteredData.filter(a => a.name === item.name).length;
            if (count > 0) {
				if(!item.name.includes('pipe')){
                count_display.innerHTML += "<b>" + item.name + ": " + count + "</b><br />";
                min_1 = true; // Set min_1 to true if any item is counted
				}
            }
        });

        if (!min_1) {
            count_display.innerHTML += "no blocks to count";
        }

        count_display.style.display = 'block';
        showingBlockCount = true;
    } else {
        count_display.style.display = 'none';
        count_display.innerHTML = "<h2>block count [BETA]:</h2><br /><br />";
        showingBlockCount = false;
    }
}


	
	
	
        let inventoryVisible = false;

        function toggleInventory() {
            const invCont = document.getElementById('inv-cont');
            const toggleHint = document.getElementById('toggle-hint');
            
            if (inventoryVisible) {
                invCont.style.display = 'none';
               // toggleHint.style.display = 'block'; // Show the hint text
            } else {
                invCont.style.display = 'block';
               // toggleHint.style.display = 'none'; // Hide the hint text
            }

            inventoryVisible = !inventoryVisible; // Toggle state
        }

		
        document.addEventListener('keydown', (event) => {
			//toggle inv shortcut
            if (event.key === 'i' || event.key === 'I') {
                toggleInventory();
            }
			//saving build shortcut
            if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                event.preventDefault(); // Prevent the default save dialog
				saveBuild() 
				return;
            }

			//toggle grid shortcut
			if (event.key === 'g' || event.key === 'G') {
				grid_view_toggle = !grid_view_toggle;
				if (grid_view_toggle) {
					showGridBorder()
				} else {
					hideGridBorder()
				}
			}
        });
		
		
		
	
		
		let activator_custom_function = {};
		let change_image_all_functions = {};
		
		
		

        
        const items = [
            { name: "steam tubes" },
			{ name: "steam gear" },
            { name: "steam bellows" },
            { name: "steam riser bellows" },
            { name: "steam piston" },
            { name: "steam lifter piston" },
            { name: "steam collector" },            
            { name: "steam funnel up" },
            { name: "steam funnel down" },
            { name: "steam funnel left" },
            { name: "steam funnel right" },
			{ name: "steam crank" },
			{ name: "steam valve left" },
			{ name: "steam valve right" },
			{ name: "steam crossover URDL" },
			{ name: "steam crossover ULDR" },
			{ name: "steam scrambler" },      
			{ name: "steam organ" },			
            { name: "steam pipe"}, //not implemented yet
			{ name: "steam vent L" },     
			{ name: "steam vent R" },   	
            { name: "steam revolver" },
			{ name: "steam stomper" },
			{ name: "steam engine L" },     
			{ name: "steam engine R" },   			
            { name: "steam door" },
			{ name: "steam launcher" },
            { name: "steam spikes" },
            { name: "steam lamp" },
           
			{ name: "copper" },

			{ name: 'steam pipe', hide: null },
			{ name: 'pipe-vertical', hide: null },
			{ name: 'pipe-horizontal', hide: null },
			{ name: 'pipe-4-junction', hide: null },
			{ name: 'pipe-3-junction-L', hide: null },
			{ name: 'pipe-3-junction-R', hide: null },
			{ name: 'pipe-3-junction-U', hide: null },
			{ name: 'pipe-3-junction-D', hide: null },
			{ name: 'pipe-corner-DL', hide: null },
			{ name: 'pipe-corner-DR', hide: null },
			{ name: 'pipe-corner-UL', hide: null },
			{ name: 'pipe-corner-UR', hide: null }
        ];
		
		
		
		  const standard_behaviour = [ 
            "steam tubes",
            "steam bellows" ,
            "steam riser bellows",
            "steam piston",
            "steam lifter piston",		
            "steam gear",
			
			
			
			"steam valve left",
			"steam valve right",
			"steam crank",
			"steam collector",
			"steam crossover URDL",
			"steam crossover ULDR",
			"steam vent L",
			"steam vent R",
		    "steam organ",
			"steam lamp",
			"steam launcher",
			"steam scrambler",
			
			"steam door",
			"steam spikes",

			'steam pipe',
			'pipe-vertical',
			'pipe-horizontal',
			'pipe-4-junction',
			'pipe-3-junction-L',
			'pipe-3-junction-R',
			'pipe-3-junction-U',
			'pipe-3-junction-D',
			'pipe-corner-DL',
			'pipe-corner-DR',
			'pipe-corner-UL',
			'pipe-corner-UR'
        ];
		
		
		const activators = [    
            { name: "steam revolver" },
            { name: "steam stomper" },
			{ name: "steam engine L" },
			{ name: "steam engine R" },
			
			
        ];

		//excluded from pipe connection
		const excludedBlocks = [
			"steam revolver",
			"steam stomper" ,
			"steam engine L" ,
			"steam engine R"
		];
		
		const single_powered = [    
            { name: "steam door" },
            { name: "steam spikes" },
			{ name: "steam lamp" },
		    { name: "steam launcher" }
        ];


        
        let gridData = Array.from({ length: 100 }, () => Array(100).fill(null)); // 2D array for grid

        const inv = document.getElementById('inv');
        const grid = document.getElementById('grid');
        const fileInput = document.getElementById('file-input');

		let betaWarned = false;

        items.forEach(item => {
			if(item.hasOwnProperty("hide")){
				return; //equal to continue in forEach
				}
				
            const div = document.createElement('div');
            div.classList.add('inv-item');
            
            const img = document.createElement('img');
            img.src = "assets/" + item.name.toLowerCase().replaceAll(" ", "-") + ".png";
            img.alt = item.name;
			img.title = item.name.replace("ULDR","").replace("URDL","");
			if(item.name.includes("pipe")){
				div.style.borderColor = "red"
				div.style.color = "red"
				div.style.textContent = "BETA"
				div.style.fontSize = "5px"
				
			}

            div.addEventListener('click', () => {
				if(item.name.includes("pipe")){
					if(!betaWarned){
					swal("BETA", "steam pipes are still in very early development and may not function as expected!", "warning");
					betaWarned = true;
					}

				}


				
                selectedItem = { name: item.name, orientation: 0 };


            });

            div.appendChild(img);
            inv.appendChild(div);
        });

        


        //GENERATE MAIN 100 BY 100 GRID
        function GenerateMainGrid(){
			for (let i = 0; i < 10000; i++) {
				const cell = document.createElement('div');
				cell.id = `grid-cell-${i}`
				cell.classList.add('grid-cell');

				cell.addEventListener('click', () => placeBlock(cell, i));
				grid.appendChild(cell);
			}
		}
		
		
		
		//WHEN PAGE IS FULLY LOADED
		window.onload = function(){
			setTimeout(toggleInventory, 1000);
			setTimeout(toggleInventory, 1000);
			GenerateMainGrid()
		}





		// Array of block names that pipes shouldn't link to
 // Add the block names here that pipes should not connect to

// Function to manage pipe textures based on neighbors
function pipeTextureManager() {
	console.log("called")
    // Loop through every row and column in the 2D grid
    if (gridData.flat().length == 0) {
        return;
    }

    for (let row = 0; row < gridData.length; row++) {
        for (let col = 0; col < gridData[row].length; col++) {
            // Ensure the cell has a 'name' property and it's a pipe
            if (gridData[row][col] && gridData[row][col].hasOwnProperty('name') && gridData[row][col].name.includes("pipe")) {
                
                // Check for pipe adjacency (U = Up, D = Down, L = Left, R = Right)
                let pipeAdj = {
                    U: row > 0 && gridData[row - 1][col] && gridData[row - 1][col].hasOwnProperty('name') && !excludedBlocks.includes(gridData[row - 1][col].name),
                    D: row < gridData.length - 1 && gridData[row + 1][col] && gridData[row + 1][col].hasOwnProperty('name') && !excludedBlocks.includes(gridData[row + 1][col].name),
                    L: col > 0 && gridData[row][col - 1] && gridData[row][col - 1].hasOwnProperty('name') && !excludedBlocks.includes(gridData[row][col - 1].name),
                    R: col < gridData[row].length - 1 && gridData[row][col + 1] && gridData[row][col + 1].hasOwnProperty('name') && !excludedBlocks.includes(gridData[row][col + 1].name)
                };

                // Assign texture and update name based on neighbors
                if (pipeAdj.U && pipeAdj.D && pipeAdj.L && pipeAdj.R) {
                    gridData[row][col].name = 'pipe-4-junction';
                    changeBlockImage(row, col, 'assets/pipe-4-junction.png'); // 4-way junction
                } else if (pipeAdj.U && pipeAdj.D && pipeAdj.L) {
                    gridData[row][col].name = 'pipe-3-junction-L';
                    changeBlockImage(row, col, 'assets/pipe-3-junction-L.png'); // 3-way left junction
                } else if (pipeAdj.U && pipeAdj.D && pipeAdj.R) {
                    gridData[row][col].name = 'pipe-3-junction-R';
                    changeBlockImage(row, col, 'assets/pipe-3-junction-R.png'); // 3-way right junction
                } else if (pipeAdj.L && pipeAdj.R && pipeAdj.U) {
                    gridData[row][col].name = 'pipe-3-junction-U';
                    changeBlockImage(row, col, 'assets/pipe-3-junction-U.png'); // 3-way top junction
                } else if (pipeAdj.L && pipeAdj.R && pipeAdj.D) {
                    gridData[row][col].name = 'pipe-3-junction-D';
                    changeBlockImage(row, col, 'assets/pipe-3-junction-D.png'); // 3-way bottom junction
                } else if (pipeAdj.L && pipeAdj.R) {
                    gridData[row][col].name = 'pipe-horizontal';
                    changeBlockImage(row, col, 'assets/pipe-horizontal.png'); // Horizontal pipe
                } else if (pipeAdj.U && pipeAdj.D) {
                    gridData[row][col].name = 'pipe-vertical';
                    changeBlockImage(row, col, 'assets/pipe-vertical.png'); // Vertical pipe
                } else if (pipeAdj.U && pipeAdj.R) {
                    gridData[row][col].name = 'pipe-corner-UR';
                    changeBlockImage(row, col, 'assets/pipe-corner-UR.png'); // Elbow (Up-Right)
                } else if (pipeAdj.U && pipeAdj.L) {
                    gridData[row][col].name = 'pipe-corner-UL';
                    changeBlockImage(row, col, 'assets/pipe-corner-UL.png'); // Elbow (Up-Left)
                } else if (pipeAdj.D && pipeAdj.R) {
                    gridData[row][col].name = 'pipe-corner-DR';
                    changeBlockImage(row, col, 'assets/pipe-corner-DR.png'); // Elbow (Down-Right)
                } else if (pipeAdj.D && pipeAdj.L) {
                    gridData[row][col].name = 'pipe-corner-DL';
                    changeBlockImage(row, col, 'assets/pipe-corner-DL.png'); // Elbow (Down-Left)
                }
            }
        }
    }
}

setInterval(pipeTextureManager,500)

// Function to update pipes after removing/adding
function updatePipesAfterChange(row, col) {
    // Check the current position and surrounding neighbors for texture updates
    const directions = [
        { r: -1, c: 0 },  // Up
        { r: 1, c: 0 },   // Down
        { r: 0, c: -1 },  // Left
        { r: 0, c: 1 }    // Right
    ];

    // Update the current pipe (if it exists)
    pipeTextureManager();

    // Update neighbors
    directions.forEach(dir => {
        let newRow = row + dir.r;
        let newCol = col + dir.c;

        // Check if the new coordinates are valid within the grid
        if (newRow >= 0 && newRow < gridData.length && newCol >= 0 && newCol < gridData[0].length) {
            pipeTextureManager();
        }
    });
}

// Call this function after a pipe is removed or added
function removePipe(row, col) {
    if (gridData[row][col]) {
        // Remove the pipe by clearing its name or setting it to something like 'empty'
        gridData[row][col].name = 'empty';
        
        // Clear the texture visually
        changeBlockImage(row, col, ''); // Assuming this clears the image

        // Update pipes around the removed pipe
        updatePipesAfterChange(row, col);
    }
}



	

			
		
		
		
		
		//changing image of a block in grid at row,col
		let image_change_queue = {}
		function changeBlockImage(row, col, image) {
			let unique_1 = unique(25)
			image_change_queue[unique_1] = function(){
				const cell = document.getElementById(`grid-cell-${row * 100 + col}`);
				if (cell && cell.hasChildNodes()) {
					const img = cell.querySelector('img');
					if (img) {
						img.src = image;
					}
				}			
			}
			setTimeout(image_change_queue[unique_1],100)
		}


		//main function to handle placing blocks on the grid
//main function to handle placing blocks on the grid
		function placeBlock(cell, i, control="build", saved_value=[]) {

		
			
	
		if(!selectedItem){
			return
		}
		
			const row = Math.floor(i / 100);
			const col = i % 100;

			if (cell.hasChildNodes()) {
				
				cell.innerHTML = '';
				cell.style.border = '2px groove  rgba(0,230,230,0.4)';
				cell.style.filter = ''; // Remove the shadow
				gridData[row][col] = "null";

				let existingButton = document.getElementById(`activator-${i}`);
				if (existingButton) {
					document.body.removeChild(existingButton);
					existingButton.remove()
				}
			} else if (selectedItem &&selectedItem.hasOwnProperty("name")) {
		
				
				const img = document.createElement('img');
				if (!selectedItem.name.includes("pipe"))
				img.src = "assets/" + selectedItem.name.toLowerCase().replaceAll(" ", "-") + ".png";
				img.alt = selectedItem.name;
				cell.appendChild(img);
				cell.style.border = 'none';
				cell.style.borderWidth = '0px'
				 // Add a shadow effect
				 cell.style.filter = block_shadow_style
				

				//handling how the object should be, depending on block
				//this can be overwritten later
				gridData[row][col] = {
					name: selectedItem.name //every block will have a name regardless of type
				};




				//pipe being placed, handler 
				if (selectedItem.name.includes("pipe")) {
					//console.log('attempt advanced pipe placement')
					gridData[row][col] = {name: selectedItem.name};
					img.src = "assets/" + "pipe-vertical" + ".png";

					pipeAdj = {
						U: gridData[row-1][col] && gridData[row-1][col].hasOwnProperty('name') && gridData[row-1][col].name.includes("pipe") ,
						D: gridData[row+1][col] && gridData[row+1][col].hasOwnProperty('name') && gridData[row+1][col].name.includes("pipe") ,
						L: gridData[row][col-1] && gridData[row][col-1].hasOwnProperty('name') && gridData[row][col-1].name.includes("pipe") ,
						R: gridData[row][col+1] && gridData[row][col+1].hasOwnProperty('name') && gridData[row][col+1].name.includes("pipe") 
					}




						if(pipeAdj.L || pipeAdj.R){
							img.src = "assets/" + "pipe-horizontal" + ".png";
						}
						else if(pipeAdj.U || pipeAdj.D){
							
							img.src = "assets/" + "pipe-vertical" + ".png";
						}
						
				}







				//handle valve block placement
				if (selectedItem.name.includes("valve")) {
					let _orientation = (selectedItem.name.includes("left")) ? "L" : "R";
					gridData[row][col] = new steam_valve(selectedItem.name, _orientation);
					console.log("valve placed-> " + gridData[row][col].orientation);
					return;
				}


				//handle steam collector block placement
				if (selectedItem.name.includes("collector")) {
					gridData[row][col] = new Steam_Collector(selectedItem.name, []);
					console.log("steam collector placed");
					return;
				}



				//block is an activator block, create activator button, (standard for all non continuous steam generators)
				if (activators.some(a => a.name === selectedItem.name) && !selectedItem.name.includes(" door") && !selectedItem.name.includes(" crank") && !selectedItem.name.includes(" vent")) {
					let button = document.createElement("button");
					button.id = `activator-${i}`;
					button.classList.add("activators");
					button.textContent = "â–¶ï¸";

					//controls activator button location
					button.style.top = `${Math.floor(i / 100) * 41}px`;
					button.style.left = `${(i % 100) * 41}px`;
					
					
					
					//activators engines/revolver/stomper
				   if(selectedItem.name.includes("stomper")){
					button.addEventListener("click", () => {
						console.log("activator button active")
						console.log(selectedItem.name)	
						let unique_1 = unique(15);
						activator_custom_function[unique_1] = function(){ steamSystem_main2(Math.floor(i / 100), i % 100,selectedItem.name) }
						activator_custom_function[unique_1]();
					});
					}
					
					if(selectedItem.name.includes("revolver")){
					button.addEventListener("click", () => {
						console.log("activator button active")
						console.log(selectedItem.name)	
						let unique_1 = unique(15);
					    activator_custom_function[unique_1] = function(){ steamSystem_main(Math.floor(i / 100), i % 100) }
						activator_custom_function[unique_1]();
					});
					}
					
					//left facing engine
					//right facing engine
					if (selectedItem.name.includes("engine L")) {
						gridData[row][col] = new steam_engine(selectedItem.name,false,null)
						console.log("Engine detected");

						button.addEventListener("click", () => {
							console.log("Activator button active");
							console.log(selectedItem.name);
							
							
								if (!gridData[row][col].active) {
									// Start the interval if not active
									gridData[row][col].interval = setInterval(() => {
										steamSystem_main4(Math.floor(i / 100), i % 100);
									}, global_engine_interval);
									steamSystem_main4(Math.floor(i / 100), i % 100);
									
									gridData[row][col].active = true;
									button.textContent = "âŽ"
								} else {
									// Clear the interval if already active
									clearInterval(gridData[row][col].interval);
									gridData[row][col].active = false;
									button.textContent = "â–¶ï¸"
								}
							
						});
				}
					
					//right facing engine
					if (selectedItem.name.includes("engine R")) {
						gridData[row][col] = new steam_engine(selectedItem.name,false,null)
						console.log("Engine detected");

						button.addEventListener("click", () => {
							console.log("Activator button active");
							console.log(selectedItem.name);
							
							
								if (!gridData[row][col].active) {
									// Start the interval if not active
									gridData[row][col].interval = setInterval(() => {
										steamSystem_main3(Math.floor(i / 100), i % 100);
									}, global_engine_interval);
									steamSystem_main3(Math.floor(i / 100), i % 100);
									
									gridData[row][col].active = true;
									button.textContent = "âŽ"
								} else {
									// Clear the interval if already active
									clearInterval(gridData[row][col].interval);
									gridData[row][col].active = false;
									button.textContent = "â–¶ï¸"
								}
							
						});
				}

					

					document.body.appendChild(button);
					button.style.opacity = "0.9"
					return;
				}

				//placing a steam crank
				if (selectedItem.name.includes("steam crank")) {
				
					let crank = new steam_crank(selectedItem.name);
					gridData[row][col] = crank;
					
					if(control == "load"){
						gridData[row][col].flow = saved_value[0];
					}

					let button = document.createElement("button");
					button.id = `activator-${i}`;
					button.classList.add("activators");
					button.textContent = "ï¸ðŸ”„";
					button.style.top = `${Math.floor(i / 100) * 41}px`;
					button.style.left = `${(i % 100) * 41}px`;

					button.addEventListener("click", () => {
						crank.toggleFlow();
						changeBlockImage(row, col, crank.getImage()) 
						console.log("steam crank rotated");
					});

					document.body.appendChild(button);
					return;
				}


				//placing a steam organ
				if (selectedItem.name.includes("steam organ")) {
					console.log("organ placed");
					let organ = new Steam_Organ(selectedItem.name, "off");
					gridData[row][col] = organ;
				}

				//placing a steam door
				if (selectedItem.name.includes("door")) {
					console.log('steam door placed');
					let door = new steam_door(selectedItem.name, "closed", row, col);
					gridData[row][col] = door; // Store the door in the grid

					let button = document.createElement("button");
					button.id = `activator-${i}`;
					button.classList.add("activators");
					button.textContent = "ï¸ðŸ”˜";
					button.style.top = `${Math.floor(i / 100) * 41}px`;
					button.style.left = `${(i % 100) * 41}px`;

					// Add event listener to toggle the state
					button.addEventListener("click", () => {
						let currentDoor = gridData[row][col]; // Get the existing door from the grid
						currentDoor.toggleState(); // Toggle the door's state
						changeBlockImage(row, col, currentDoor.getImage());  // Update the image
						console.log("steam door state changed: " + currentDoor.state);
					});

					document.body.appendChild(button);
					return;
				}
				
				if (selectedItem.name.includes("launcher")) {
					console.log('steam launcher placed');
					let launcher = new steam_launcher(selectedItem.name, "off");
					gridData[row][col] = launcher; // Store the launcher in the grid

					let button = document.createElement("button");
					button.id = `activator-${i}`;
					button.classList.add("activators");
					button.textContent = "ï¸â®";
					button.style.top = `${Math.floor(i / 100) * 41}px`;
					button.style.left = `${(i % 100) * 41}px`;

					// Add event listener to toggle the state
					button.addEventListener("click", () => {
						let currentLauncher = gridData[row][col]; // Get the existing launcher from the grid
						currentLauncher.deactivate() // Toggle the launcher's state
						currentLauncher.updateImg(row,col)
						console.log("steam launcher state changed: " + currentLauncher.state);
					});

					document.body.appendChild(button);
					return;
				}

				
				//placing steam vent
				if (selectedItem.name.includes("vent")) {
					let vent_direction = (selectedItem.name.includes("L") ? "L" : "R");
					console.log("vent placed + " + vent_direction);
					let vent = new steam_vent(selectedItem.name, "off", vent_direction);

					gridData[row][col] = vent; // Store the vent in the grid-cell
					return;
				}
				
				//placing steam spike
				if (selectedItem.name.includes("spike")) {
					console.log("spike placed ");
					let spike = new steam_spike(selectedItem.name, "off");
					spike.updateImg(row,col);
					gridData[row][col] = spike; // Store the spike in the grid-cell
					return;
				}
				
				
				//placing steam lamp
				if (selectedItem.name.includes("lamp")) {
					console.log("lamp placed ");
					let lamp = new steam_lamp(selectedItem.name, "off");
					gridData[row][col] = lamp; // Store the lamp in the grid-cell
					return;
				}
				
				

			}
			
			
		} 

			  





		//get data of blocks adjacent to input (row,col)
		let adjLatency = {}
		function adj(row, col) {
			let unique_1 = unique(20)
			
			adjLatency[unique_1] = function(){
				const adjacent = [];
				const rows = gridData.length;
				const cols = gridData[0].length;

				// Up
				let upBlock = row > 0 ? gridData[row - 1][col] || "null" : "null";
				if (upBlock !== "null" && upBlock.hasOwnProperty('name') && upBlock.name.includes("valve")) {
					adjacent.push(upBlock); // If vent is above, allow it
				} else {
					adjacent.push(upBlock); // Otherwise, behave as normal
				}

				// Down
				let downBlock = row < rows - 1 ? gridData[row + 1][col] || "null" : "null";
				if (downBlock !== "null" && downBlock.hasOwnProperty('name') && downBlock.name.includes("valve")) {
					adjacent.push(downBlock); // If vent is below, allow it
				} else {
					adjacent.push(downBlock); // Otherwise, behave as normal
				}

				// Left
				let leftBlock = col > 0 ? gridData[row][col - 1] || "null" : "null";
				if (leftBlock !== "null" && leftBlock.hasOwnProperty('name') && leftBlock.name.includes("valve")) {
					leftBlock = "null"; // If vent is on the left, treat it as null
				}
				adjacent.push(leftBlock);

				// Right
				let rightBlock = col < cols - 1 ? gridData[row][col + 1] || "null" : "null";
				if (rightBlock !== "null" && rightBlock.hasOwnProperty('name') && rightBlock.name.includes("valve")) {
					rightBlock = "null"; // If vent is on the right, treat it as null
				}
				adjacent.push(rightBlock);

				console.log(adjacent);
				return adjacent;
			}
			return adjLatency[unique_1]();
			
		}
		
		
		
		
		
		const arrow_mapper = {
			U:"âˆ§",
			D:"âˆ¨",
			L:"<",
			R:">"
		}
		




		
		let blockDatasLatency = {}
		function getBlockData(row,col){
			let unique_1 = unique(20)
			blockDatasLatency[unique_1] = function(){
				let cell = document.getElementById(`grid-cell-${row * 100 + col}`)
				let in_grid = gridData[row][col]
				return in_grid;
			}
			return blockDatasLatency[unique_1]()
		}	




		
		
		//unused template
		class general_steam_component {
			constructor(name){
				this.name = name;
			}
		}
		
		
		
		//steam engine class
		class steam_engine{
			constructor(name,active,interval){
				this.name = name;
				this.active = active;
				this.interval = interval;
			}
		}
		
		
		//steam spike class
		class steam_spike {
			constructor(name,state="off"){
				this.name = name;
				this.state = state;
			}
			
			toggleState(){
				this.state = this.state=="off"?"on":"off";
			}
			
			updateImg(row,col){
				changeBlockImage(row,col,this.getImage());
			}
			
			getImage(){
				return this.state=="on"?"assets/steam-spikes.png":"assets/steam-spikes-off.png"
			}
		}
		
			//steam launcher class
		class steam_launcher {
			constructor(name,state="off"){
				this.name = name;
				this.state = state;
			}
			
			toggleState(){
				this.state = this.state=="off"?"on":"off";
			}
			
			activate(){
				this.state = "on"
			}
			deactivate(){
				this.state = "off"
			}
			
			updateImg(row,col){
				let unique_1 = unique(15)
				let instance = this;
				change_image_all_functions[unique_1] = function(){	changeBlockImage(row,col,instance.getImage())}
				change_image_all_functions[unique_1]();
			
			}
			
			getImage(){
				return this.state=="on"?"assets/steam-launcher-on.png":"assets/steam-launcher.png"
			}
		}
		
		
		
		
		//steam vent class
		class steam_vent {
			constructor(name, state = "off", vent_direction) {
				this.name = name;
				this.state = state;
				this.vent_direction = vent_direction;
				this.timeout = null; // Keep track of the timeout
			}

			// Activate function to turn on the vent, wait, then turn it off
			activate(row, col) {
				// Always reset vent duration on activation
				console.log('vent activated, resetting duration');

				// Turn the vent "on"
				this.state = "on";
				let instance = this;
				let unique_1 = unique(20)
				change_image_all_functions[unique_1] = function(){ changeBlockImage(row, col, "assets/steam-vent-" + instance.vent_direction + "-on.png")}
				change_image_all_functions[unique_1]()

				// Clear any existing timeout to avoid multiple overlapping timeouts
				if (this.timeout) {
					clearTimeout(this.timeout);
					console.log('previous vent timeout cleared');
				}

				// Set a new timeout to turn off the vent after the specified duration
				this.timeout = setTimeout(() => {
					this.state = "off";
					let instance = this;
					let unique_1 = unique(20)
					change_image_all_functions[unique_1] = function(){ changeBlockImage(row, col, "assets/steam-vent-" + instance.vent_direction + ".png")}
					change_image_all_functions[unique_1]()
					console.log('vent off');
					this.timeout = null; // Reset the timeout variable
				}, global_vent_max_duration); // Use the global vent duration
			}
		}
		
		
		
		class steam_lamp{
			constructor(name, state = "off") {
				this.name = name;
				this.state = state;
				this.timeout = null; // Keep track of the timeout
			}

			// Activate function to turn on the lamp, wait, then turn it off
			activate(row, col) {
				console.log('lamp activated, resetting duration');

				// Turn the lamp "on"
				this.state = "on";
				let unique_1 = unique(15)
				change_image_all_functions[unique_1] = function(){ 	changeBlockImage(row, col, "assets/steam-lamp-on.png") }
				change_image_all_functions[unique_1]()
			

				// Clear any existing timeout to avoid multiple overlapping timeouts
				if (this.timeout) {
					clearTimeout(this.timeout);
					console.log('previous lamp timeout cleared');
				}

				// Set a new timeout to turn off the lamp after the specified duration
				this.timeout = setTimeout(() => {
					this.state = "off";
					let unique_1 = unique(15)
					change_image_all_functions[unique_1] = function(){ changeBlockImage(row, col, "assets/steam-lamp.png") };
					change_image_all_functions[unique_1]()
					console.log('lamp off');
					this.timeout = null; // Reset the timeout variable
				}, global_lamp_max_duration); // Use the global lamp duration
			}
		}
		
		
		
		
		//steam collector class (work in progress)
		class Steam_Collector {
			constructor(name, puffs=[]){
				this.name = name;
				this.puffs = puffs;
			}
		}
		
		
		//steam organ class
		class Steam_Organ {
			constructor(name,state="off",audio=global_organ_frequency){
				this.name = name;
				this.audio = audio;
				this.state = state;
				this.timeout = null;
			}
			
			activate(row, col) {
				console.log('organ activated, resetting duration');
				
				this.state = "on";
				changeBlockImage(row, col, "assets/steam-organ-on.png") 
				
				
				playTone(this.audio, global_organ_max_duration/1000) 

				// Clear any existing timeout to avoid multiple overlapping timeouts
				if (this.timeout) {
					clearTimeout(this.timeout);
					console.log('previous vent timeout cleared');
				}

				// Set a new timeout to turn off the organ after the specified duration
				this.timeout = setTimeout(() => {
					this.state = "off";
			     	changeBlockImage(row, col, "assets/steam-organ.png")
					console.log('organ off');
					this.timeout = null; 
				}, global_organ_max_duration); 
			}
			
		}

		
		
		
		
		
		//steam door class
		class steam_door {
			constructor(name, state="closed", row, col) {
				this.name = name;
				this.state = state;
				this.row = row;
				this.col = col;
			}

			toggleState() {
				this.state = this.state === "closed" ? "open" : "closed";
			}

			getImage() {
				return this.state === "closed" ? "assets/steam-door.png" : "assets/steam-door-open.png";
			}
			updateImg(row,col){
				changeBlockImage(row,col,this.getImage()) 
			}
		}

		
		
		
		// steam crank class
		class steam_crank {
			constructor(name, flow = "vertical") {
				this.name = name;
				this.flow = flow;
			}

			toggleFlow() {
				if (this.flow === "vertical") {
					this.flow = "horizontal";
				} else {
					this.flow = "vertical";
				}
			}
			
			// Method to update the crank image on the grid
			updateImg(row, col) {
				changeBlockImage(row, col, this.getImage()) // Update image based on flow state
				console.log("flow:"+this.flow+" "+this.getImage())
			}

			getImage() {
				return this.flow === "vertical" ? 'assets/steam-crank.png' : 'assets/steam-crank-horizontal.png';
			}
		}


		
		
		//steam valve class
		class steam_valve {
			constructor(name,orientation){
				this.name = name;
				this.orientation = orientation;
			}
			switch_orientation(){
				if(this.orientation == "L"){
					this.orientation = "R";
					console.log("new orientation:"+this.orientation)
				}
				else if(this.orientation == "R"){
					this.orientation = "L";
					console.log("new orientation:"+this.orientation)
				}
			}
			getImage() {
				return this.orientation === "L" ? 'assets/steam-valve-left.png' : 'assets/steam-valve-right.png';
			}
			
			updateImg(row,col){
				changeBlockImage(row,col,this.getImage()) 		
			}
		}




		//steam puff mechanics
		let Steam_Puffs = []
		const id_length = 5;
		
		
		class Puff {
			constructor(current_direction,position={row:null,col:null},distance_moved=0,collector_max_duration=global_collector_max_duration,unique_id,foundSpot = false,ele=null){
				this.current_direction = current_direction;
				this.position = position
				this.unique_id = unique(id_length);
				this.distance_moved = distance_moved;
				this.collector_max_duration = collector_max_duration;				
				this.foundSpot = foundSpot;
				this.ele = ele;		
				this.true_puff_speed = global_true_puff_speed;
				this.puff_speed = this.true_puff_speed
				this.max_puff_distance = max_puff_distance;
				//generate the new puff visually
				setTimeout(()=>{this.generate_puff(this.position.row,this.position.col)},this.puff_speed)
			}
			
			//generate a new steam puff visually
			generate_puff(row,col){
				 let cell = document.getElementById(`grid-cell-${ parseInt(this.position.row) * 100 + parseInt(this.position.col)}`);
			     if (cell) {
					// Create and display a new steam puff element
					const puffElement = document.createElement('div');
					puffElement.id = "puff-" + this.unique_id
					
					puffElement.style.opacity = 0.7
					puffElement.classList.add('steam-puff');
					puffElement.style.top = '0px'; 
					puffElement.style.left = '0px'; 
					this.distance_moved+=1
					puffElement.textContent = (this.max_puff_distance-this.distance_moved) + "\n"+this.current_direction
					let scaledValue = Math.round((this.distance_moved / 99) * 255); // Scale distance to 1-255 range
					puffElement.style.backgroundColor = "rgb(" + scaledValue + "," + (255 - scaledValue) + ",90)";
					this.ele = puffElement;
					Steam_Puffs.push(this);
					cell.appendChild(puffElement)
					document.getElementById('puff-counter').innerHTML = "Active steam puff count: " + Steam_Puffs.length;
					setTimeout(()=>{this.recursive_move()},this.puff_speed)
				 }
	 
		}
		
		
		
		//method to kill puff
		kill_puff(){	
		try{
				console.log(document.getElementById("puff-" + this.unique_id));
				document.getElementById("puff-" + this.unique_id).remove();
				Steam_Puffs.splice(Steam_Puffs.indexOf(Steam_Puffs.filter(a=>a.unique_id==this.unique_id)[0]),1);	
				Steam_Puffs.splice(Steam_Puffs.indexOf(this),1);		
				document.getElementById('puff-counter').innerHTML = "Active steam puff count: " + Steam_Puffs.length;
				}
				catch(e){
					console.log("error killing : " + e)
					Steam_Puffs.splice(Steam_Puffs.indexOf(Steam_Puffs.filter(a=>a.unique_id==this.unique_id)[0]),1);		
					document.getElementById('puff-counter').innerHTML = "Active steam puff count: " + Steam_Puffs.length;
					return
				}
				return;
		}
		
		//method to check if puff has found a spot to move to, if not kill the puff
		check_found_spot(){
			console.log('found spot:'+this.foundSpot)
			
			if(this.foundSpot == false){
					this.kill_puff();
					return;
				}
				
		}
		
		
		
		//recursive motion function
			recursive_move(){
			if(!document.getElementById("puff-" + this.unique_id)){
				this.kill_puff()
				console.log(Steam_Puffs.length)
				return;
			}


			if(this.distance_moved >= this.max_puff_distance){
				console.log('max')
				this.kill_puff()
				return;
			}
			
			
			try{	
				if(this.distance_moved >= this.max_puff_distance){
					console.log('max')
				this.kill_puff()
				return;
				}

				this.foundSpot = false; 
				
				console.log('moved/max:'+this.distance_moved+"/"+max_puff_distance)
				if(this.distance_moved==max_puff_distance){
					//kill steam puff
					this.kill_puff()
					console.log("puff kill was attempted- max distance")
					return;
				}
			
				let adjCells = adj(this.position.row,this.position.col);
				
				//adjacent cells validity checks
				let ValidArr = {
				  U: adjCells[0] !== null && adjCells[0] !== undefined && adjCells[0].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[0].name) || adjCells[0].name.includes("funnel")  || adjCells[0].name.includes("pipe")),
					//up

				  D: adjCells[1] !== null && adjCells[1] !== undefined && adjCells[1].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[1].name) || adjCells[1].name.includes("funnel") || adjCells[1].name.includes("pipe")),
					  //down
					 

				  L: adjCells[2] !== null && adjCells[2] !== undefined && adjCells[2].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[2].name) || adjCells[2].name.includes("funnel")  || adjCells[2].name.includes("pipe")),
					 //left

				  R: adjCells[3] !== null && adjCells[3] !== undefined && adjCells[3].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[3].name) || adjCells[3].name.includes("funnel")  || adjCells[3].name.includes("pipe")),
					 //right
				};

				if(this.distance_moved >= this.max_puff_distance){
				this.kill_puff()
				return;
				}



				//new check for vertical crank, spawned in it
				if(gridData[this.position.row][this.position.col].name.includes("crank")){
					if(gridData[this.position.row][this.position.col].flow == "vertical"){
						ValidArr["L"] = null;
						ValidArr["R"] = null;
					}
				}
				
				
				//currently in a steam door block
				if(gridData[this.position.row][this.position.col].name.includes("door")){
					//gridData[ this.position.row][ this.position.col].updateImg(this.position.row,this.position.col)
					gridData[this.position.row][this.position.col].toggleState();
					gridData[ this.position.row][ this.position.col].updateImg(this.position.row,this.position.col)
					let instance = this;
					setTimeout(function(){instance.kill_puff()},this.puff_speed)
					return;
				}
				
				
				//steam spike,launcher and lamp advanced move limiter
				if(adjCells[1]){
					if(adjCells[1].hasOwnProperty('name')){
						if(adjCells[1].name.includes("spike")||adjCells[1].name.includes("lamp")||adjCells[1].name.includes("launcher")){					
							ValidArr["D"] = null
							adjCells[1] = null
							console.log('limited')
						}
					}
				}
				
				if(adjCells[2]){
					if(adjCells[2].hasOwnProperty('name')){
						if(adjCells[2].name.includes("spike")||adjCells[2].name.includes("lamp")||adjCells[2].name.includes("launcher")){					
							ValidArr["L"] = null
							adjCells[2] = null
							console.log('limited')
						}
					}
				}
				
				if(adjCells[3]){
					if(adjCells[3].hasOwnProperty('name')){
						if(adjCells[3].name.includes("spike")||adjCells[3].name.includes("lamp")||adjCells[3].name.includes("launcher")){						
							ValidArr["R"] = null
							adjCells[3] =null
							console.log('limited')
						}
					}
				}
				
				
				//steam crank further limiter
				if(gridData[this.position.row][this.position.col]){
					if(gridData[this.position.row][this.position.col].hasOwnProperty('name')){
						if(gridData[this.position.row][this.position.col].name.includes('crank')){
							if(gridData[this.position.row][this.position.col].flow == "horizontal"){
								ValidArr["U"] = null
								adjCells[0] =null
								ValidArr["D"] = null
								adjCells[1] = null
								console.log('crank-limited')
							}
						}
					}
				}
				
				
				
				
				//if its currently at an organ, activate organ
				if(gridData[this.position.row][this.position.col].name.includes("organ")){
					console.log("currently in steam organ");
					gridData[this.position.row][this.position.col].activate(this.position.row,this.position.col);
				}
				
				
				
				//slow down speed if in steam collector
				if(gridData[this.position.row][this.position.col].name.includes("collector")){
					console.log("slowing puff down..."+ this.puff_speed);
					 this.puff_speed = collector_puff_speed;
				}
				else{
					//if not use regular speed
					console.log("puff_speed_reset"+  this.puff_speed);
					 this.puff_speed =  this.true_puff_speed;
				}
				
				
			
				
				
				//ULDR steam crossover handler
				if (gridData[this.position.row][this.position.col].name.includes("ULDR")) {
					console.log("Currently in ULDR crossover");

					// Check if adjacent cells are valid before changing direction
					if (this.current_direction == "U" && ValidArr["R"]) {
						this.changePosition("R", this.position.row, this.position.col+1);
					} else if (this.current_direction == "D" && ValidArr["L"]) {
						this.changePosition("L", this.position.row, this.position.col-1);
					} else if (this.current_direction == "L" && ValidArr["D"]) {
						this.changePosition("D", this.position.row+1, this.position.col);
					} else if (this.current_direction == "R" && ValidArr["U"]) {
						this.changePosition("U", this.position.row-1, this.position.col);
					} else {
						// If no valid move, kill the puff
						this.kill_puff();
					}

					this.check_found_spot();
					setTimeout(() => { this.recursive_move(); },  this.puff_speed);
					return;
				}
				
							
				// URDL steam crossover handler
				if (gridData[this.position.row][this.position.col].name.includes("URDL")) {
					console.log("Currently in URDL crossover");

					// Check if adjacent cells are valid before changing direction
					if (this.current_direction == "U" && ValidArr["L"]) {
						this.changePosition("L", this.position.row, this.position.col-1);
					} else if (this.current_direction == "D" && ValidArr["R"]) {
						this.changePosition("R", this.position.row, this.position.col+1);
					} else if (this.current_direction == "L" && ValidArr["U"]) {
						this.changePosition("U", this.position.row-1, this.position.col);
					} else if (this.current_direction == "R" && ValidArr["D"]) {
						this.changePosition("D", this.position.row+1, this.position.col);
					} else {
						// If no valid move, kill the puff
						this.kill_puff();
					}

					this.check_found_spot();
					setTimeout(() => { this.recursive_move(); },  this.puff_speed);
					return;
				}

				
				
				if(this.distance_moved >= this.max_puff_distance){
				this.kill_puff()
				return;
				}
				
				
			
				
					
				
				//prevent back flow of steam, note applies for collectors, collectors go below this
				if(this.current_direction=="U"){
				 if(!gridData[this.position.row][this.position.col].name.includes("funnel"))
				 ValidArr.D = null
				}
				if(this.current_direction=="D"){
					 if(!gridData[this.position.row][this.position.col].name.includes("funnel"))
				 ValidArr.U = null
				}
				if(this.current_direction=="L"){
					 if(!gridData[this.position.row][this.position.col].name.includes("funnel"))
				 ValidArr.R = null
				}
				if(this.current_direction=="R"){
					 if(!gridData[this.position.row][this.position.col].name.includes("funnel"))
				 ValidArr.L = null
				}





				
				
				if(adjCells[2]){
					if(adjCells[2].hasOwnProperty("name")&&adjCells[2].name.includes("vent")){
				    	adjCells[2] = null
						ValidArr["L"] = null						
					}
					}
					
					if(adjCells[3]){
					if(adjCells[3].hasOwnProperty("name")&&adjCells[3].name.includes("vent")){					
						adjCells[3] = null
						ValidArr["R"] = null
					}
					}
				
				
				
				
				//currently puff is in a valve block, handle movement from valve
				if(gridData[this.position.row][this.position.col].name.includes("valve")){
					console.log("valve encountered")
					let valve = gridData[this.position.row][this.position.col]
					
					
					//check if exit direction of valve leads to a valid block
					//check if standard valve behaviour is possible
					if(ValidArr[valve.orientation]!="null"&&ValidArr[valve.orientation]){
						//valve leads to valid block				
							console.log('valve attempt valid exit:'+valve.orientation);
							if(valve.orientation=="L"){
								this.changePosition("L",this.position.row,this.position.col)
								valve.switch_orientation();
								valve.updateImg(this.position.row,this.position.col)
								console.log("switched orientation:"+valve.orientation)
							}
							else if(valve.orientation=="R"){
								this.changePosition("R",this.position.row,this.position.col)
								valve.switch_orientation();
								valve.updateImg(this.position.row,this.position.col)
								console.log("switched orientation:"+valve.orientation)
							}							
					}
					
					//if standard behaviour is not possible, leads to invalid
					//go straight direction
					else{
						if(this.current_direction=="U"){
							if(ValidArr["U"]!="null"&&ValidArr["U"]){
								this.changePosition("U",this.position.row,this.position.col);
								}
								else{
									valve.switch_orientation()
									valve.updateImg(this.position.row,this.position.col)
									this.kill_puff()
									return;
									console.log("kill attempt"+this.current_direction)
								}
							}
							else if(this.current_direction=="D"){
						if(ValidArr["D"]!="null"&&ValidArr["D"]){
									this.changePosition("D",this.position.row,this.position.col);
									}
									else{
										valve.switch_orientation()
										valve.updateImg(this.position.row,this.position.col)
										this.kill_puff()
										return;
										console.log("kill attempt"+this.current_direction)
									}
							}
							else{
								this.kill_puff()
								console.log("kill attempt"+this.current_direction)
							}
						
							
						valve.switch_orientation();
						valve.updateImg(this.position.row,this.position.col)
						console.log("switched orientation:"+valve.orientation)
						
					}
					
					

					
					
					this.check_found_spot();
					//setTimeout(()=>{this.recursive_move()}, this.puff_speed)
					
				}
				
				
				
					
						
				//steam crank system to prevent motion to improper crank
				//obtaining current block infront of steam puff
				let adj_block = adj(this.position.row,this.position.col)
				let block;
				if(this.current_direction=="U"){
					block = adj_block[0]
				}
				if(this.current_direction=="D"){
					block = adj_block[1]
				}
				if(this.current_direction=="L"){
					block = adj_block[2]
				}
				if(this.current_direction=="R"){
					block = adj_block[3]
				}
				
				//steam crank system to prevent motion to improper crank
				if(block.hasOwnProperty("name")){
				if(block.name.includes("crank")){
					if(this.current_direction=="U"&&block.flow=="horizontal"){
						alert("v")
						ValidArr.U = null
					}
					if(this.current_direction=="D"&&block.flow=="horizontal"){
						ValidArr.D = null
					}
					if(this.current_direction=="L"&&block.flow=="vertical"){
						ValidArr.L = null
					}
					if(this.current_direction=="R"&&block.flow=="vertical"){
						ValidArr.R = null
					}
					
					
				}
				}
				
				
				if(adj_block[1]){
				if(adj_block[1].hasOwnProperty("flow")){			
						if(this.current_direction=="L"&&adj_block[1].flow=="horizontal"){
							ValidArr["D"] = null
							adj_block[1] = null
						}
						if(this.current_direction=="R"&&adj_block[1].flow=="horizontal"){
							ValidArr["D"] = null
							adj_block[1] = null
						}
					}
					}
					
				
				if(adjCells[0]){
				if(adjCells[0].hasOwnProperty("flow")){			
						if(this.current_direction=="L"&&adjCells[0].flow=="horizontal"){
							ValidArr["U"] = null
							adjCells[0] = null
						}
						if(this.current_direction=="R"&&adjCells[0].flow=="horizontal"){
							ValidArr["U"] = null
							adjCells[0] = null
						}
					}
				}
					
				
				if(adj_block[2]){
				if(adj_block[2].hasOwnProperty("flow")){			
						if(this.current_direction=="D"&&adj_block[2].flow=="vertical"){
							ValidArr["L"] = null
							adj_block[2] = null
						}
						if(this.current_direction=="U"&&adj_block[2].flow=="vertical"){
							ValidArr["L"] = null
							adj_block[2] = null
							
						}
					}
					}
				
				
				if(adj_block[3]){
				if(adj_block[3].hasOwnProperty("flow")){			
						if(this.current_direction=="D"&&adj_block[3].flow=="vertical"){
							ValidArr["R"] = null
							adj_block[3] = null
						}
						if(this.current_direction=="U"&&adj_block[3].flow=="vertical"){
							ValidArr["R"] = null
							adj_block[3] = null
						}
					}
				}
					
							
				
				//vent system (new)
				if (gridData[this.position.row][this.position.col].name.includes("vent")) {
				// Activate the vent
				gridData[this.position.row][this.position.col].activate(this.position.row, this.position.col);
					if(ValidArr[this.current_direction]==true){ 
					if(this.current_direction=="U")
						this.changePosition("U",this.position.row,this.position.col);
					if(this.current_direction=="D")
						this.changePosition("D",this.position.row,this.position.col);
					}
					else{
						this.kill_puff()
					}
					if(this.distance_moved >= this.max_puff_distance){
						this.kill_puff()
					}
				}
				
				
				
				//activate lamp and kill puff
				if (gridData[this.position.row][this.position.col].name.includes("lamp")) {
					// Activate the lamp
					gridData[this.position.row][this.position.col].activate(this.position.row, this.position.col);				
					let instance = this;
					setTimeout(function(){instance.kill_puff()},this.puff_speed)
					return;
				}
				
				//activate launcher and kill puff
				if (gridData[this.position.row][this.position.col].name.includes("launcher")) {
					// Activate the launcher
					gridData[this.position.row][this.position.col].activate();		
					gridData[this.position.row][this.position.col].updateImg(this.position.row,this.position.col)		
					let instance = this;
					setTimeout(function(){instance.kill_puff()},this.puff_speed)
					return;
				}
									
				
				//steam spike system activates spike and kills puff
				if(gridData[this.position.row][this.position.col].name.includes("spike")){		
					gridData[this.position.row][this.position.col].updateImg();
					gridData[this.position.row][this.position.col].toggleState();
					gridData[this.position.row][this.position.col].updateImg(this.position.row,this.position.col);
					let instance = this;
					setTimeout(function(){instance.kill_puff()},this.puff_speed)
					return;
				}
				


				
				if(this.distance_moved >= this.max_puff_distance){
				this.kill_puff()
				return;
				}
			



		
			//currently puff is in a funnel block, handle movement from funnel
				if(gridData[this.position.row][this.position.col].name.includes("funnel")){
					console.log('currently in funnel')
					
					if(gridData[this.position.row][this.position.col].name.includes("up")){
							console.log(ValidArr['U'])
							if(ValidArr['U']&&ValidArr['U']!='null'){
							console.log('up funnel')
							this.changePosition("U",this.position.row-1,this.position.col)
							}
							else{
								this.kill_puff()
								return
							}
					
						
					}
					else if(gridData[this.position.row][this.position.col].name.includes("down")){
							console.log(ValidArr['D'])
							if(ValidArr['D']&&ValidArr['D']!='null'){
							console.log('down funnel')
							this.changePosition("D",this.position.row+1,this.position.col)
							}
							else{
								this.kill_puff()
								return
							}
						
					}
					else if(gridData[this.position.row][this.position.col].name.includes("left")){
						if(ValidArr['L']&&ValidArr['L']!='null'){
							console.log('left funnel')
							this.changePosition("L",this.position.row,this.position.col-1)
							}
							else{
								this.kill_puff()
								return
							}
						
					}
					else if(gridData[this.position.row][this.position.col].name.includes("right")){
					if(ValidArr['R']&&ValidArr['R']!='null'){
							console.log('right funnel')
							this.changePosition("R",this.position.row,this.position.col+1)
						}
						else{
								this.kill_puff()
								return
							}
						
					}
					
					
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				   return;
				}
				
				
				
			
				if(this.distance_moved >= this.max_puff_distance){
				this.kill_puff()
				return;
				}



			//PRIMATIVE SYSTEM BELOW THIS LINE
			
			
				console.log("BLOCK:"+gridData[this.position.row][this.position.col].name+" -Valid Array:"+Object.values(ValidArr))
				
				//steam scrambler system
				if(gridData[this.position.row][this.position.col].name.includes('scrambler')){
					console.log('steam scrambler system active')				
					
					let possibleKeys = Object.keys(ValidArr).filter(key => 
					  ValidArr[key] != null && ValidArr[key] != 'null' && ValidArr[key] != false
					);
					
					//srcambler cant proceed anywhere, kill puff
					if(possibleKeys.length==0){
						console.log('scrambler cant proceed, kill puff')
						this.kill_puff();
						return;
					}
					
					
					console.log('possible spot count: '+possibleKeys.length);
					
					let randomKey = possibleKeys[Math.floor(Math.random() * possibleKeys.length)]
					console.log('selected output: '+ randomKey)
					this.changePosition(randomKey,this.position.row,this.position.col)
				
				}
			
			
	

if (gridData[this.position.row][this.position.col].name.includes('collector')) {
    const possibleKeys = Object.keys(ValidArr).filter(key => ValidArr[key]);
	const current_collector = gridData[this.position.row][this.position.col];

    if (possibleKeys.length >= 2 && current_collector.puffs.length < possibleKeys.length) {
        
        // Add puff to collector if it's not already present
        if (!current_collector.puffs.some(puff => puff.unique_id === this.unique_id)) {
            current_collector.puffs.push(this);
			document.getElementById("puff-"+this.unique_id).style.backgroundColor = 'violet'
			document.getElementById("puff-"+this.unique_id).textContent = this.max_puff_distance-this.distance_moved+"\nwait"
            // Set a 20-second timer to remove the puff if it stays too long
            this.timeoutId = setTimeout(() => {
                current_collector.puffs = current_collector.puffs.filter(p => p.unique_id !== this.unique_id);
                console.log(`Puff ${this.unique_id} killed after 20 seconds in the collector.`);
                this.kill_puff();
            }, global_collector_max_duration);
        }

        console.log(`Collector puff count: ${current_collector.puffs.length}`);

        // Release puffs when the number of valid directions equals the number of puffs
        if (possibleKeys.length === current_collector.puffs.length) {
            console.log('Releasing steam puffs from collector...');
			let index = 0

            // Create new puffs based on directions
            possibleKeys.forEach(direction => {
                let new_puff;
				
                switch (direction) {
                    case "U":
                        new_puff = new Puff("U", { row: this.position.row-1, col: this.position.col });
                        break;
                    case "D":
                        new_puff = new Puff("D", { row: this.position.row+1, col: this.position.col });
                        break;
                    case "L":
                        new_puff = new Puff("L", { row: this.position.row, col: this.position.col-1 });
                        break;
                    case "R":
                        new_puff = new Puff("R", { row: this.position.row, col: this.position.col+1 });
                        break;
                }
				new_puff.distance_moved = current_collector.puffs[index].distance_moved;
				index++;
            });

            // Kill all puffs in the collector and clear the list
            current_collector.puffs.forEach(puff => puff.kill_puff());
			this.kill_puff()
            current_collector.puffs = [];
			return;
        } else {
            // Wait for more puffs if not all are ready
            return;
        }
    }
}








if(this.distance_moved >= this.max_puff_distance){
				this.kill_puff()
				return;
}
			


				
				
				//standard straight motion system
				if(ValidArr[this.current_direction]==true){ //can move straight
					console.log("straight line motion");
					if(this.current_direction=="U")
						this.changePosition("U",this.position.row-1,this.position.col);
					if(this.current_direction=="D")
						this.changePosition("D",this.position.row+1,this.position.col);
					if(this.current_direction=="L")
						this.changePosition("L",this.position.row,this.position.col-1);
					if(this.current_direction=="R")
						this.changePosition("R",this.position.row,this.position.col+1);
					
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				
				//right movement puff logic
				else if(this.current_direction=="U" && ValidArr["R"] ){
					this.changePosition("R",this.position.row,this.position.col+1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				else if(this.current_direction=="D" && ValidArr["L"] ){
					this.changePosition("L",this.position.row,this.position.col-1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				else if(this.current_direction=="L" && ValidArr["U"] ){
					this.changePosition("U",this.position.row-1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				else if(this.current_direction=="R" && ValidArr["D"] ){
					this.changePosition("D",this.position.row+1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				
				//left movement puff logic
				else if(this.current_direction=="U" && ValidArr["L"] ){
					this.changePosition("L",this.position.row,this.position.col-1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				else if(this.current_direction=="D" && ValidArr["R"] ){
					this.changePosition("R",this.position.row,this.position.col+1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				else if(this.current_direction=="L" && ValidArr["D"] ){
					this.changePosition("D",this.position.row+1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}
				else if(this.current_direction=="R" && ValidArr["U"] ){
					this.changePosition("U",this.position.row-1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()}, this.puff_speed)
				}


				if(this.distance_moved >= this.max_puff_distance){
				this.kill_puff()
				return;
				}

					}catch(e){console.log(e)}
				this.check_found_spot();
			
			}
			
			
			//change puff position in grid
				changePosition(newDirection, newRow, newCol) {
				document.getElementById('puff-counter').innerHTML = "Active steam puff count: " + Steam_Puffs.length;
					
				// Get the current cell and new cell in the grid
				const currentCell = document.getElementById(`grid-cell-${this.position.row * 100 + this.position.col}`);
				const newCellIndex = newRow * 100 + newCol;
				const newCell = document.getElementById(`grid-cell-${newCellIndex}`);

				// Find the puff element in the current cell
				const puffElement = document.getElementById(`puff-${this.unique_id}`);
				if (puffElement) {
					// Remove puff element from the current cell
					if (currentCell) {
						currentCell.removeChild(puffElement);
					}

					// Append puff element to the new cell
					if (newCell) {
						puffElement.style.top = "0px"
						puffElement.style.left = "0px"
						this.current_direction = newDirection;
						
						
						console.log(this.position.col+","+newCol+"|"+this.position.row+","+newRow)
						if(!(newRow==this.position.row&&newCol==this.position.col)){
							//increment distance moved
							if(this.distance_moved+1 >= this.max_puff_distance){
								console.log('max')
								this.kill_puff()
								return;
							}
							this.distance_moved += 1;
						}
						else{
							console.log('increment prevention!')
						}


						let scaledValue = Math.round((this.distance_moved / 99) * 255); // Scale distance to 1-255 range
						puffElement.style.backgroundColor = "rgb(" + scaledValue + "," + (255 - scaledValue) + ",90)";
						puffElement.textContent = (this.max_puff_distance-this.distance_moved) + "\n"+this.current_direction

						this.foundSpot = true;
						newCell.appendChild(puffElement);
					}

					// Update puff's position
					this.position = {row:newRow, col:newCol};
				}
			}

		}

		
		
		
		
		let activator_queue = {}
		
		
		
		 //used for revolver
		 function steamSystem_main(act_r, act_c) {        
			let unique_1 = unique(20);
			
			activator_queue[unique_1] = function(){
           // console.log(gridData);
            const adjCells = adj(act_r, act_c);
			
			//additional check for spike/lamp/launcher below
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('spike')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('lamp')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('launcher')){
					adjCells[1] = null
				}
			}
			
			//more sus crank checks
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('crank')){
				if(adjCells[1].flow=="horizontal")
					adjCells[1] = null
				}
			}
			if(adjCells[0]){
				if(adjCells[0].hasOwnProperty('name')&&adjCells[0].name.includes('crank')){
				if(adjCells[0].flow=="horizontal")
					adjCells[0] = null
				}
			}

            
            adjCells.forEach((cell, index) => {
			if(cell)
                console.log(`Adjacent ${index}: ${cell === "null" ? "null" : cell.name}`);
            });

			  if (
			  adjCells[0] !== null && adjCells[0] !== undefined && 
			  adjCells[0].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[0].name) || 
				adjCells[0].name.includes("funnel")
			  )
			) {
	
			  //spawn puff up
			  let _puff = new Puff("U", { row: act_r - 1, col: act_c });
			} 
			else if (
			  adjCells[1] !== null && adjCells[1] !== undefined && 
			  adjCells[1].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[1].name) || 
				adjCells[1].name.includes("funnel")
			  )
			) {
		
			  //spawn puff down
			  let _puff = new Puff("D", { row: act_r + 1, col: act_c });
			} 
			else {
			  //nowhere to propagate to
			}

		}
		activator_queue[unique_1]()

        }
			

		//used for stomper
       function steamSystem_main2(act_r, act_c, provider="") {
		//	console.log(gridData);
			
			let adjCells = adj(act_r, act_c); // Get adjacent cells
			
			//additional check for spike/lamp below
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('spike')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('lamp')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('launcher')){
					adjCells[1] = null
				}
			}
						
			//more sus crank checks
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('crank')){
				if(adjCells[1].flow=="horizontal")
					adjCells[1] = null
				}
			}
			if(adjCells[0]){
				if(adjCells[0].hasOwnProperty('name')&&adjCells[0].name.includes('crank')){
				if(adjCells[0].flow=="horizontal")
					adjCells[0] = null
				}
			}


			// Function to check if a cell is valid
			function isValidCell(cell) {
				return cell !== null && cell !== undefined && cell.hasOwnProperty('name');
			}

			// Function to check if propagation should occur
			function shouldPropagate(cell) {
				return standard_behaviour.includes(cell.name) || cell.name.includes("funnel");
			}

			// Function to handle puff propagation
			function handlePuff(direction, newRow, newCol) {
				let _puff = new Puff(direction, { row: newRow, col: newCol });
			}

			// Check and handle "sus crank" for a specific cell
			function checkSusCrank(row, col, directionIndex) {
				const cell = gridData[row][col];
				if (cell.name.includes("crank") && cell.flow === "horizontal") {
					console.log("Caught sus crank, treating as null");
					adjCells[directionIndex] = null; // Treat this cell as null
					return true; // Crank detected
				}
				return false; // No crank detected
			}

			// Main propagation logic
			function propagate() {
			console.log(provider)
				if (isValidCell(adjCells[0]) && shouldPropagate(adjCells[0])&&!provider=="steam stomper") {
				console.log(provider)
					// Check for sus crank and treat as null if found
					if (checkSusCrank(act_r - 1, act_c, 0)) {
						propagate(); // Retry after marking crank as null
						return;
					}
					// Move up
					handlePuff("U", act_r - 1, act_c);
				} 
				else if (isValidCell(adjCells[1]) && shouldPropagate(adjCells[1])) {
					// Check for sus crank and treat as null if found
					if (checkSusCrank(act_r + 1, act_c, 1)) {
						propagate(); // Retry after marking crank as null
						return;
					}
					// Move down
					handlePuff("D", act_r + 1, act_c);
				} 
				else {
					// No valid direction to propagate to
					console.log("No valid direction for puff propagation");
				}
			}

			// Initial propagation attempt
			propagate();
		}

	
	
	
	
	
	
	
	
	
	
	
	
	//for engines
	 function steamSystem_main3(act_r, act_c) {        
			let unique_1 = unique(20);
			
			activator_queue[unique_1] = function(){
         //   console.log(gridData);
            const adjCells = adj(act_r, act_c);
			
			//additional check for spike/lamp/launcher below
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('spike')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('lamp')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('launcher')){
					adjCells[1] = null
				}
			}
			
			//more sus crank checks
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('crank')){
				if(adjCells[1].flow=="horizontal")
					adjCells[1] = null
				}
			}
			if(adjCells[0]){
				if(adjCells[0].hasOwnProperty('name')&&adjCells[0].name.includes('crank')){
				if(adjCells[0].flow=="horizontal")
					adjCells[0] = null
				}
			}
			
			//additonal for engine
			const checkAndNullify = (cell) => {
				if (cell && cell.hasOwnProperty('name')) {
					if ((cell.name.includes('valve') || cell.name.includes('vent'))) {
						return null;
					}
					if ((cell.name.includes('spike') || cell.name.includes('lamp')|| cell.name.includes('launcher'))) {
						return null;
					}
					if(cell.hasOwnProperty('flow')&&cell.flow=="vertical")
						return null;
				}
				return cell;
			};
			adjCells[2] = checkAndNullify(adjCells[2]);
			adjCells[3] = checkAndNullify(adjCells[3]);


            
            adjCells.forEach((cell, index) => {
			if(cell)
                console.log(`Adjacent ${index}: ${cell === "null" ? "null" : cell.name}`);
            });
			
			  if (
			  adjCells[3] !== null && adjCells[3] !== undefined && 
			  adjCells[3].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[3].name) || 
				adjCells[3].name.includes("funnel")
			  )
			){
				//spawn puff right
			  let _puff = new Puff("R", { row: act_r, col: act_c +1});
			} 

			  else if (
			  adjCells[0] !== null && adjCells[0] !== undefined && 
			  adjCells[0].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[0].name) || 
				adjCells[0].name.includes("funnel")
			  )
			) {
	
			  //spawn puff up
			  let _puff = new Puff("U", { row: act_r - 1, col: act_c });
			} 
			else if (
			  adjCells[1] !== null && adjCells[1] !== undefined && 
			  adjCells[1].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[1].name) || 
				adjCells[1].name.includes("funnel")
			  )
			) {
		
			  //spawn puff down
			  let _puff = new Puff("D", { row: act_r + 1, col: act_c });
			} 
			else {
			  //nowhere to propagate to
			}

		}
		activator_queue[unique_1]()

        }
		
		
		
		//left engine
		function steamSystem_main4(act_r, act_c) {        
			let unique_1 = unique(20);
			
			activator_queue[unique_1] = function(){
         //  console.log(gridData);
            const adjCells = adj(act_r, act_c);
			
			//additional check for spike/lamp/launcher below
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('spike')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('lamp')){
					adjCells[1] = null
				}
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('launcher')){
					adjCells[1] = null
				}
			}
			
			//more sus crank checks
			if(adjCells[1]){
				if(adjCells[1].hasOwnProperty('name')&&adjCells[1].name.includes('crank')){
				if(adjCells[1].flow=="horizontal")
					adjCells[1] = null
				}
			}
			if(adjCells[0]){
				if(adjCells[0].hasOwnProperty('name')&&adjCells[0].name.includes('crank')){
				if(adjCells[0].flow=="horizontal")
					adjCells[0] = null
				}
			}
			
			//additonal for engine
			const checkAndNullify = (cell) => {
				if (cell && cell.hasOwnProperty('name')) {
					if ((cell.name.includes('valve') || cell.name.includes('vent'))) {
						return null;
					}
					if ((cell.name.includes('spike') || cell.name.includes('lamp')|| cell.name.includes('launcher'))) {
						return null;
					}
					if(cell.hasOwnProperty('flow')&&cell.flow=="vertical")
						return null;
				}
				return cell;
			};
			adjCells[2] = checkAndNullify(adjCells[2]);
			adjCells[3] = checkAndNullify(adjCells[3]);


            
            adjCells.forEach((cell, index) => {
			if(cell)
                console.log(`Adjacent ${index}: ${cell === "null" ? "null" : cell.name}`);
            });
			
			  if (
			  adjCells[2] !== null && adjCells[2] !== undefined && 
			  adjCells[2].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[2].name) || 
				adjCells[2].name.includes("funnel")
			  )
			){
				//spawn puff left
			  let _puff = new Puff("L", { row: act_r, col: act_c -1});
			} 

			  else if (
			  adjCells[0] !== null && adjCells[0] !== undefined && 
			  adjCells[0].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[0].name) || 
				adjCells[0].name.includes("funnel")
			  )
			) {
	
			  //spawn puff up
			  let _puff = new Puff("U", { row: act_r - 1, col: act_c });
			} 
			else if (
			  adjCells[1] !== null && adjCells[1] !== undefined && 
			  adjCells[1].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[1].name) || 
				adjCells[1].name.includes("funnel")
			  )
			) {
		
			  //spawn puff down
			  let _puff = new Puff("D", { row: act_r + 1, col: act_c });
			} 
			else {
			  //nowhere to propagate to
			}

		}
		activator_queue[unique_1]()

        }
</script>
</body>
</html>
