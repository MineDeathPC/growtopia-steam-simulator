<!DOCTYPE html>
<html>
<head>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">

    <style>
        body {
		
            background-image: url("assets/bg.jpg");
            background-repeat: repeat;
            background-size: 15cm;
            margin: 0;
			
			
			font-family: 'Roboto Mono', monospace;
			font-optical-sizing: auto;
			--font-weight: 400; /* Default weight */
			--font-style: normal; /* Default style */
    
        }

        #inv-cont {
            position: fixed;
            top: 0;
            left: 0;
            width: auto;
            padding: 0;
            z-index: 10;
            background-color: rgba(4,158,129,0.5);
            border: 10px double darkcyan;
            border-radius: 20px;
        }

        #inv {
            display: grid;
            grid-template-columns: repeat(13, 50px); /* 13 items per row */
            gap: 6px;
            padding: 10px;
        }

        .inv-item {
            width: 40px;
            height: 40px;
            background-color: darkgrey;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid cyan;
            border-radius: 5px;
            overflow: hidden;
            cursor: pointer;
        }

        .inv-item img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(100, 40px); /* 100 columns with each cell 40px wide */
            grid-template-rows: repeat(100, 40px);    /* 100 rows with each cell 40px tall */
            gap: 1px;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        .grid-cell {
            width: 40px;
            height: 40px;
            background-color: rgba(100,255,255,0.07);
            border: 1px solid rgba(60,50,120,0.5);
            position: relative; /* For positioning steam puffs */
            overflow: hidden;
        }

        .grid-cell img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

       
        .steam-puff {
			position: absolute;
			font-family: 'Roboto Mono', monospace;
			width: 100%;
			height: 100%;
			background-color: green;
			opacity: 0.7;
			color: cyan;
			font-size: 0.55cm;
			text-align: center;
			font-weight: bold;
			border-radius: 0px;
			animation: flash 1s linear infinite;
			pointer-events: none;
		}
		
		@keyframes flash{
			0%{background-color:green; color: cyan;}
			50%{background-color:white; color: black;}
			100%{background-color:green; color: cyan;}
		}


       

        #toggle-hint {
            display:block;
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 10;
            color: white;
            background-color: rgba(0, 0, 0, 0.3);
			font-family: 'Roboto Mono', monospace;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 10px;
        }

        #load-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 20;
            padding: 10px 20px;
            background-color: #4CAF50;
			font-family: 'Roboto Mono', monospace;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        #load-button input[type="file"] {
            display: none;
        }

        .activators {
            position: absolute;
            z-index: 1;
            font-size: 0.55cm;
            border: none;
            background: none;
            cursor: pointer;
			opacity:0.6;
        }

        .activators:hover {
          opacity:1;
		  font-size: 0.58cm;
        }
		
		
		
		
    </style>
</head>

<body>
    <div id="inv-cont">
        <div id="inv"></div>
    </div>

    <div id="grid"></div>

    <!-- Hint text for showing inventory -->
    <button id="toggle-hint" onclick="toggleInventory()">Tap or press I to open/close Inventory</button>

    <!-- Load JSON Button -->
    <button id="load-button" alt="ctrl+s to save json">Load JSON</button>
    <input type="file" id="file-input" accept=".json" style="display: none;">

    <script>
		function unique(length) {
		let result = '';
		const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
		const charactersLength = characters.length;
		let counter = 0;
		while (counter < length) {
		  result += characters.charAt(Math.floor(Math.random() * charactersLength));
		  counter += 1;
		}
		return result;
	}

        let inventoryVisible = false;


		
		
		
		
        function toggleInventory() {
            const invCont = document.getElementById('inv-cont');
            const toggleHint = document.getElementById('toggle-hint');
            
            if (inventoryVisible) {
                invCont.style.display = 'none';
               // toggleHint.style.display = 'block'; // Show the hint text
            } else {
                invCont.style.display = 'block';
               // toggleHint.style.display = 'none'; // Hide the hint text
            }

            inventoryVisible = !inventoryVisible; // Toggle state
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'i' || event.key === 'I') {
                toggleInventory();
            }
            if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                event.preventDefault(); // Prevent the default save dialog
				alert("not currently functional, sorry")
				return;
                saveGrid();
            }
        });

        const activators = [
            { name: "steam engine" },
            { name: "steam revolver" },
            { name: "steam stomper" }
        ];
        const items = [
            { name: "steam tubes" },
			{ name: "steam gear" },
			{ name: "steam organ" },
            { name: "steam bellows" },
            { name: "steam riser bellows" },
            { name: "steam piston" },
            { name: "steam lifter piston" },
            { name: "steam collector" },            
            { name: "steam funnel up" },
            { name: "steam funnel down" },
            { name: "steam funnel left" },
            { name: "steam funnel right" },
			{ name: "steam crank" },
			{ name: "steam valve left" },
			{ name: "steam valve right" },
			{ name: "steam crossover URDL" },
			{ name: "steam crossover ULDR" },
			{ name: "steam scrambler" },       
            { name: "steam pipe" },
			{ name: "steam vent" },			
            { name: "steam revolver" },
			{ name: "steam stomper" },
			{ name: "steam engine" },           
            { name: "steam door" },
			{ name: "steam launcher" },
            { name: "steam spikes" },
            { name: "steam lamp" },
           
			{ name: "copper" }
        ];

        let selectedItem = null;
        let gridData = Array.from({ length: 100 }, () => Array(100).fill(null)); // 2D array for grid

        const inv = document.getElementById('inv');
        const grid = document.getElementById('grid');
        const fileInput = document.getElementById('file-input');

        items.forEach(item => {
            const div = document.createElement('div');
            div.classList.add('inv-item');
            
            const img = document.createElement('img');
            img.src = "assets/" + item.name.toLowerCase().replaceAll(" ", "-") + ".png";
            img.alt = item.name;

            div.addEventListener('click', () => {
                selectedItem = { name: item.name, orientation: 0 };
            });

            div.appendChild(img);
            inv.appendChild(div);
        });

        setTimeout(toggleInventory, 1000);
        setTimeout(toggleInventory, 1000);

        for (let i = 0; i < 10000; i++) {
            const cell = document.createElement('div');
			cell.id = `grid-cell-${i}`
            cell.classList.add('grid-cell');

            cell.addEventListener('click', () => placeBlock(cell, i));
            grid.appendChild(cell);
        }
		
		function changeBlockImage(row, col, image) {
    const cell = document.getElementById(`grid-cell-${row * 100 + col}`);
    if (cell && cell.hasChildNodes()) {
        const img = cell.querySelector('img');
        if (img) {
            img.src = image;
        }
    }
}

        function placeBlock(cell, i) {
            const row = Math.floor(i / 100);
            const col = i % 100;

            if (cell.hasChildNodes()) {
                cell.innerHTML = '';
                cell.style.border = '1px solid rgba(60,50,120,0.5)';
                gridData[row][col] = "null";

                const existingButton = document.getElementById(`activator-${i}`);
                if (existingButton) {
                    document.body.removeChild(existingButton);
                }
            } else if (selectedItem) {
                const img = document.createElement('img');
                img.src = "assets/" + selectedItem.name.toLowerCase().replaceAll(" ", "-") + ".png";
                img.alt = selectedItem.name;
                cell.appendChild(img);
                cell.style.border = 'none';
				
				//handling how the object should be, depending on block
                gridData[row][col] = { 
                    name: selectedItem.name
                };
				
				//handle valve data
				if(selectedItem.name.includes("valve")){
					let _orientation = (selectedItem.name.includes("left"))?"L":"R";
					gridData[row][col] = new steam_valve(selectedItem.name,_orientation);
					console.log("valve placed-> "+gridData[row][col].orientation);
				}
				
				
             

				//block is an activator block, create activator button
                if (activators.some(a => a.name === selectedItem.name)) {
                    let button = document.createElement("button");
                    button.id = `activator-${i}`;
                    button.classList.add("activators");
                    button.textContent = "▶️";
                    button.style.top = `${Math.floor(i / 100) * 40}px`;
                    button.style.left = `${(i % 100) * 40}px`;

                    button.addEventListener("click", () => {
                       console.log("activator button active")
                       steamSystem_main(Math.floor(i / 100), i % 100)
                    });

                    document.body.appendChild(button);
                }
				else if (selectedItem.name.includes("steam crank")) {
					let crank = new steam_crank(selectedItem.name);
					gridData[row][col] = crank;

					let button = document.createElement("button");
					button.id = `activator-${i}`;
					button.classList.add("activators");
					button.textContent = "️🔄";
					button.style.top = `${Math.floor(i / 100) * 40}px`;
					button.style.left = `${(i % 100) * 40}px`;

					button.addEventListener("click", () => {
						crank.toggleFlow();
						changeBlockImage(row, col, crank.getImage());
						console.log("steam crank rotated");
					});

					document.body.appendChild(button);
				}
            }
        }

        function saveGrid() {
            const gridJson = JSON.stringify(gridData);
            const blob = new Blob([gridJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'grid.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = () => {
                    gridData = JSON.parse(reader.result);
                    updateGridFromData();
                };
                reader.readAsText(file);
            }
        });

        function updateGridFromData() {
            gridData.forEach((row, r) => {
                row.forEach((cell, c) => {
                    const cellDiv = grid.children[r * 100 + c];
                    if (cellDiv) {
                        if (cell) {
                            cellDiv.innerHTML = '';
                            const img = document.createElement('img');
                            img.src = "assets/" + cell.name.toLowerCase().replaceAll(" ", "-") + ".png";
                            img.alt = cell.name;
                            cellDiv.appendChild(img);

                            if (activators.some(a => a.name === cell.name)) {
                                let button = document.createElement("button");
                                button.id = `activator-${r * 100 + c}`;
                                button.classList.add("activators");
                                button.textContent = "▶️";
                                button.style.top = `${r * 40}px`;
                                button.style.left = `${c * 40}px`;

                                button.addEventListener("click", () => {
                                    
                                    steamSystem_main(r, c)
                                });
                                document.body.appendChild(button);
                            }
                        } else {
                            cellDiv.innerHTML = '';
                            cellDiv.style.border = '1px solid rgba(60,50,120,0.5)';
                        }
                    }
                });
            });
        }

        const standard_behaviour = [ 
            "steam tubes",
            "steam bellows" ,
            "steam riser bellows",
            "steam piston",
            "steam lifter piston",
            "steam gear",
			
			"steam valve left",
			"steam valve right"
			
        ];


		//get data of blocks adjacent to input (row,col)
    function adj(row, col) {
    const adjacent = [];
    const rows = gridData.length;
    const cols = gridData[0].length;

    // Up
    let upBlock = row > 0 ? gridData[row - 1][col] || "null" : "null";
    if (upBlock !== "null" && upBlock.hasOwnProperty('name') && upBlock.name.includes("valve")) {
        adjacent.push(upBlock); // If vent is above, allow it
    } else {
        adjacent.push(upBlock); // Otherwise, behave as normal
    }

    // Down
    let downBlock = row < rows - 1 ? gridData[row + 1][col] || "null" : "null";
    if (downBlock !== "null" && downBlock.hasOwnProperty('name') && downBlock.name.includes("valve")) {
        adjacent.push(downBlock); // If vent is below, allow it
    } else {
        adjacent.push(downBlock); // Otherwise, behave as normal
    }

    // Left
    let leftBlock = col > 0 ? gridData[row][col - 1] || "null" : "null";
    if (leftBlock !== "null" && leftBlock.hasOwnProperty('name') && leftBlock.name.includes("valve")) {
        leftBlock = "null"; // If vent is on the left, treat it as null
    }
    adjacent.push(leftBlock);

    // Right
    let rightBlock = col < cols - 1 ? gridData[row][col + 1] || "null" : "null";
    if (rightBlock !== "null" && rightBlock.hasOwnProperty('name') && rightBlock.name.includes("valve")) {
        rightBlock = "null"; // If vent is on the right, treat it as null
    }
    adjacent.push(rightBlock);

    console.log(adjacent);
    return adjacent;
}


		

		
		
		


		const arrow_mapper = {
			U:"∧",
			D:"∨",
			L:"<",
			R:">"
		}
		
		
		
		function getBlockData(row,col){
			let cell = document.getElementById(`grid-cell-${row * 100 + col}`)
			let in_grid = gridData[row][col]
			return in_grid;
		}	





		class general_steam_component {
			constructor(name){
				this.name = name;
			}
		}
		
		
		class steam_crank {
			constructor(name, flow = "vertical") {
				this.name = name;
				this.flow = flow;
			}

			toggleFlow() {
				if (this.flow === "vertical") {
					this.flow = "horizontal";
				} else {
					this.flow = "vertical";
				}
			}

			getImage() {
				return this.flow == "vertical" ? 'assets/steam-crank.png' : 'assets/steam-crank-horizontal.png';
			}
		}

		
		class steam_valve {
			constructor(name,orientation){
				this.name = name;
				this.orientation = orientation;
			}
			switch_orientation(){
				if(this.orientation == "L"){
					this.orientation = "R";
					console.log("new orientation:"+this.orientation)
				}
				else if(this.orientation == "R"){
					this.orientation = "L";
					console.log("new orientation:"+this.orientation)
				}
			}
		}


		let Steam_Puffs = []
		const id_length = 5;
		const puff_speed = 100;//0.1s (default)
		const max_puff_distance = 99;//99 (based on actual game)
		const global_collector_max_duration = 10;
		
		class Puff {
			constructor(current_direction,position={row:null,col:null},distance_moved=0,collector_max_duration=global_collector_max_duration,unique_id,foundSpot = false){
				this.current_direction = current_direction;
				this.position = position
				this.unique_id = unique(id_length);
				this.distance_moved = distance_moved;
				this.collector_max_duration = collector_max_duration;
				this.generate_puff(this.position.row,this.position.col)	
				this.foundSpot = foundSpot;
			}
			
			//generate a new steam puff visually
			generate_puff(row,col){
				 let cell = document.getElementById(`grid-cell-${ parseInt(this.position.row) * 100 + parseInt(this.position.col)}`);
			     if (cell) {
					// Create and display a new steam puff element
					const puffElement = document.createElement('div');
					puffElement.id = "puff-" + this.unique_id
					puffElement.innerHTML = this.current_direction
					puffElement.style.opacity = 0.7
					puffElement.classList.add('steam-puff');
					puffElement.style.top = '0px'; 
					puffElement.style.left = '0px'; 
					this.distance_moved+=1
					Steam_Puffs.push(this);
					cell.appendChild(puffElement)
					setTimeout(()=>{this.recursive_move()},puff_speed)
				 }
	 
		}
		
		kill_puff(){
			try{
				Steam_Puffs.splice(Steam_Puffs.indexOf(this),1);
				document.getElementById("puff-" + this.unique_id).remove();
			}
			catch(e){
				console.log("failed-kill:"+e);
			}
		}
		
		check_found_spot(){
			console.log('found spot:'+this.foundSpot)
			if(this.foundSpot == false){
					this.kill_puff();
					return;
				}
		}
		
		//recursive motion function
			recursive_move(){
				this.foundSpot = false; 
				
				console.log('moved/max:'+this.distance_moved+"/"+max_puff_distance)
				if(this.distance_moved==max_puff_distance){
					//kill steam puff
					this.kill_puff()
					console.log("puff kill was attempted- max distance")
					return;
				}
			
				let adjCells = adj(this.position.row,this.position.col);
				
				let ValidArr = {
				  U: adjCells[0] !== null && adjCells[0] !== undefined && adjCells[0].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[0].name) || adjCells[0].name.includes("funnel")), // up

				  D: adjCells[1] !== null && adjCells[1] !== undefined && adjCells[1].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[1].name) || adjCells[1].name.includes("funnel")), // down

				  L: adjCells[2] !== null && adjCells[2] !== undefined && adjCells[2].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[2].name) || adjCells[2].name.includes("funnel")), // left

				  R: adjCells[3] !== null && adjCells[3] !== undefined && adjCells[3].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[3].name) || adjCells[3].name.includes("funnel"))  // right
				};
				
				
				
				//currently puff is in a funnel block, handle movement from funnel
				if(getBlockData(this.position.row,this.position.col).name.includes("funnel")){
					console.log('currently in funnel')
					
					if(getBlockData(this.position.row,this.position.col).name.includes("up")){
						if(ValidArr["U"]){
							console.log('up funnel')
							this.changePosition("U",this.position.row-1,this.position.col)
						}
					}
					else if(getBlockData(this.position.row,this.position.col).name.includes("down")){
						if(ValidArr["D"]){
							console.log('down funnel')
							this.changePosition("D",this.position.row+1,this.position.col)
						}
					}
					else if(getBlockData(this.position.row,this.position.col).name.includes("left")){
						if(ValidArr["L"]){
							console.log('left funnel')
							this.changePosition("L",this.position.row,this.position.col-1)
						}
					}
					else if(getBlockData(this.position.row,this.position.col).name.includes("right")){
						if(ValidArr["R"]){
							console.log('right funnel')
							this.changePosition("R",this.position.row,this.position.col+1)
						}
					}
					
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
						return;
				}
				
				
				
				
				//currently puff is in a valve block, handle movement from valve
				if(gridData[this.position.row][this.position.col].name.includes("valve")){
					console.log("valve encountered")
					let valve = gridData[this.position.row][this.position.col]
					
					
					//check if exit direction of valve leads to a valid block
					//check if standard valve behaviour is possible
					if(ValidArr[valve.orientation]){
						//valve leads to valid block				
							console.log('valve attempt valid exit:'+valve.orientation);
							if(valve.orientation=="L"){
								this.changePosition("L",this.position.row,this.position.col-1)
								valve.switch_orientation();
								console.log("switched orientation:"+valve.orientation)
							}
							else if(valve.orientation=="R"){
								this.changePosition("R",this.position.row,this.position.col+1)
								valve.switch_orientation();
								console.log("switched orientation:"+valve.orientation)
							}							
					}
					
					//if standard behaviour is not possible, leads to invalid
					//go straight direction
					else{
						if(this.current_direction=="U")
							this.changePosition("U",this.position.row-1,this.position.col);
						if(this.current_direction=="D")
							this.changePosition("D",this.position.row+1,this.position.col);
						if(this.current_direction=="L")
							this.changePosition("L",this.position.row,this.position.col-1);
						if(this.current_direction=="R")
							this.changePosition("R",this.position.row,this.position.col+1);
							
						valve.switch_orientation();
						console.log("switched orientation:"+valve.orientation)
					}
					
					

					
					
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
					return;
				}
				
			


				
				//prevent back flow of steam, note applies for collectors, collectors go below this
				if(this.current_direction=="U"){
				 ValidArr.D = "null"
				}
				if(this.current_direction=="D"){
				 ValidArr.U = "null"
				}
				if(this.current_direction=="L"){
				 ValidArr.R = "null"
				}
				if(this.current_direction=="R"){
				 ValidArr.L = "null"
				}
				
				if(ValidArr[this.current_direction]==true){ //can move straight
					console.log("straight line motion");
					if(this.current_direction=="U")
						this.changePosition("U",this.position.row-1,this.position.col);
					if(this.current_direction=="D")
						this.changePosition("D",this.position.row+1,this.position.col);
					if(this.current_direction=="L")
						this.changePosition("L",this.position.row,this.position.col-1);
					if(this.current_direction=="R")
						this.changePosition("R",this.position.row,this.position.col+1);
					
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				
				//right movement puff logic
				else if(this.current_direction=="U" && ValidArr["R"] ){
					this.changePosition("R",this.position.row,this.position.col+1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				else if(this.current_direction=="D" && ValidArr["L"] ){
					this.changePosition("L",this.position.row,this.position.col-1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				else if(this.current_direction=="L" && ValidArr["U"] ){
					this.changePosition("U",this.position.row-1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				else if(this.current_direction=="R" && ValidArr["D"] ){
					this.changePosition("D",this.position.row+1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				
				//left movement puff logic
				else if(this.current_direction=="U" && ValidArr["L"] ){
					this.changePosition("L",this.position.row,this.position.col-1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				else if(this.current_direction=="D" && ValidArr["R"] ){
					this.changePosition("R",this.position.row,this.position.col+1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				else if(this.current_direction=="L" && ValidArr["D"] ){
					this.changePosition("D",this.position.row+1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				else if(this.current_direction=="R" && ValidArr["U"] ){
					this.changePosition("U",this.position.row-1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				
				this.check_found_spot();
			}
			
			
			//change puff position in grid
				changePosition(newDirection, newRow, newCol) {
				// Get the current cell and new cell in the grid
				const currentCell = document.getElementById(`grid-cell-${this.position.row * 100 + this.position.col}`);
				const newCellIndex = newRow * 100 + newCol;
				const newCell = document.getElementById(`grid-cell-${newCellIndex}`);

				// Find the puff element in the current cell
				const puffElement = document.getElementById(`puff-${this.unique_id}`);
				if (puffElement) {
					// Remove puff element from the current cell
					if (currentCell) {
						currentCell.removeChild(puffElement);
					}

					// Append puff element to the new cell
					if (newCell) {
						puffElement.style.top = "0px"
						puffElement.style.left = "0px"
						this.current_direction = newDirection;
						puffElement.innerHTML = this.current_direction
						//increment distance moved
						this.distance_moved+=1;
						this.foundSpot = true;
						newCell.appendChild(puffElement);
					}

					// Update puff's position
					this.position = {row:newRow, col:newCol};
				}
			}

		}

		
			
			

        function steamSystem_main(act_r, act_c) {        
            console.log(gridData);
            const adjCells = adj(act_r, act_c);

            
            adjCells.forEach((cell, index) => {
                console.log(`Adjacent ${index}: ${cell === "null" ? "null" : cell.name}`);
            });

			  if (
			  adjCells[0] !== null && adjCells[0] !== undefined && 
			  adjCells[0].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[0].name) || 
				adjCells[0].name.includes("funnel")
			  )
			) {
			  //alert('up');
			  let _puff = new Puff("U", { row: act_r - 1, col: act_c });
			} 
			else if (
			  adjCells[1] !== null && adjCells[1] !== undefined && 
			  adjCells[1].hasOwnProperty('name') &&
			  (
				standard_behaviour.includes(adjCells[1].name) || 
				adjCells[1].name.includes("funnel")
			  )
			) {
			  //alert('down');
			  let _puff = new Puff("D", { row: act_r + 1, col: act_c });
			} 
			else {
			  //nowhere to propagate to
			}



        }
		
		const loadButton = document.getElementById('load-button');
loadButton.addEventListener('click', () => {
	alert("not currently functional, sorry")
	return;
    fileInput.click();
});
    </script>
</body>
</html>
