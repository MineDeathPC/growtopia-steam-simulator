<!DOCTYPE html>
<!--This program was created by MineDeath, Instagram: minedeath.gt-->
<!--Growtopia is licensed by Ubisoft, I do not own the game or its assets in any way-->




<html>
<head>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
<link rel="manifest" href="manifest.json">
<link rel="stylesheet" href="main.css">

 <title>Steam Simulator</title>
    <!--ustom PNG favicon -->
    <link rel="icon" type="image/png" href="assets/steam-tubes.png">
<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1"/>

</head>

<body>
  <div class="orientation-message"style="color:white;">
        Please rotate your device to landscape mode.
    </div>
	
	  <div class="content">
    <div id="inv-cont">
        <div id="inv"></div>
    </div>
	

    <div id="grid"></div>
	
	<div id="top-bar"></div>
   

    <!-- Hint text for showing inventory -->
    <button id="toggle-hint" onclick="toggleInventory()">Tap or press I to open/close Inventory</button>
	
	

    <!-- Toggle Grid Button -->
    <button id="show_grid_button" alt="toggle grid" onclick="mobileToggle()">Toggle Grid (G)</button>
	
	 
     <button id="save_build_button" onclick="saveBuild()">Save Build</button>
	 <button id="load_build_button" onclick="loadBuild()">Load Build</button>
	 <button id="load_example_build_button" style="display:none;">Load Examples</button>
    <div id="example-builds-container" style="display:none; position:fixed; width:50%; height:50%; z-index:15; top:50%; left:50%; transform:translate(-50%, -50%); padding:20px; background:white; border:1px solid 	#ccc; box-shadow:0px 0px 10px rgba(0, 0, 0, 0.1);"></div>
	
	
<div class="fixed-text">Created By: <i style="color:rgb(0,255,0);">  MineDeath </i></div>
	
<!-- end of all content-->
</div>
<input type="file" id="file-input" style="display:none;" onchange="loadFile(event)"/>
<!-- wait for body to fully load-->
<script src = "sweetalert.js"></script>
<script src = "index.js"></script>
<script>

/*
function saveBuild(){swal("404","not implemented yet, sorry!","error")}
function loadBuild(){swal("404","not implemented yet, sorry!","error")}
*/


document.getElementById('load_example_build_button').addEventListener('click', () => {
    const container = document.getElementById('example-builds-container');
    container.innerHTML = ''; // Clear previous content
    container.style.display = 'block';

    // Define the path to your example builds folder
    const folderPath = 'example_builds/';

    // This function would simulate listing files in the directory.
    // Note: You need a server to actually serve and list these files.
    // For static files served by a server, you need to maintain a file list manually or via server-side scripting.
    
    // Example file list (normally, you'd fetch this list dynamically from a server)
    const files = [
     "nice-house.json",
	 "nice-idk.json"
    ];

     files.forEach(file => {
        const button = document.createElement('button');
        button.className = 'button';
        const label = file.split('.')[0].replace(/-/g, ' '); // Convert file name to label
        button.textContent = label;
		button.classList.add('examplebutton')
        button.onclick = () => {
            const xhr = new XMLHttpRequest();
            xhr.open('GET', `example_builds/${file}`, true);
            xhr.onload = function() {
                if (xhr.status >= 200 && xhr.status < 300) {
                    try {
                        const data = JSON.parse(xhr.responseText);
						     const simulatedFile = new File([data], file, { type: 'application/json' });
                        // Pass the simulated file to the loadFile function
                        const event = {
                            target: {
                                files: [simulatedFile]
                            }
                        };
                        loadFile(event); // Call your loadFile function
                        console.log('Loaded file content:', data);
                        // Process and display the JSON data as needed
                    } catch (error) {
                        console.error('Error parsing JSON:', error);
                    }
                } else {
                    console.error('Error loading file:', xhr.statusText);
                }
            };
            xhr.onerror = function() {
                console.error('Request failed');
            };
            xhr.send();
        };
        container.appendChild(button);
    });
});








const itemsWithState = ["steam crank", "steam door"];

// Function to extract the specific state based on the block type
function getBlockState(block) {
    if (!block) return null;

    // Handle specific blocks that retain different types of state
    if (block.name === "steam crank") {
		console.log("saved+"+block.flow)
        return block.flow; // Return the flow state for cranks
    } else if (block.name === "steam door") {
		console.log("saved+"+block.state)
        return block.state; // Return the door state for doors (e.g., "open" or "closed")
    } else {
        return null; // No state to save for other blocks
    }
}

// Save build function
function saveBuild() {
	swal("BETA","Saving and loading builds is still in beta development, expect bugs!","warning")
    const simplifiedGridData = gridData.map(row => 
        row.map(block => {
            if (block) {
                if (itemsWithState.includes(block.name)) {
				console.log("saved++"+getBlockState(block) )
                    return { name: block.name, state: getBlockState(block) }; // Save both name and specific state
                } else {
                    return { name: block.name }; // Save only the name for other blocks
                }
            } else {
                return null;
            }
        })
    );

    const blob = new Blob([JSON.stringify(simplifiedGridData)], { type: "application/json" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "steam_simulator_build.json";
    link.click();
}

// Load build function
function loadBuild() {
	swal("BETA","Saving and loading builds is still in beta development, expect bugs!","warning")
    document.getElementById('file-input').click(); // Trigger file input
}

// Load build function
function loadFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        const content = e.target.result;
        try {
            const loadedGridData = JSON.parse(content);
            resetGrid(); // Clear the existing grid before loading

            // Apply loaded data to the grid
            loadedGridData.forEach((row, rowIndex) => {
                row.forEach((blockData, colIndex) => {
                    if (blockData) {
                        selectedItem = { name: blockData.name, orientation: 0 }; // Reset orientation by default
                        
                        // Check if the block has a saved state and restore it
                        if (blockData.state) {
                            restoreBlockState(blockData, blockData.state, rowIndex, colIndex); // Restore the specific state and update image
                        }

                        // Use the existing placeBlock function for placing the block
                        placeBlock(document.getElementById(`grid-cell-${rowIndex * 100 + colIndex}`), rowIndex * 100 + colIndex);
                    }
                });
            });
        } catch (err) {
            alert("Failed to load build. Invalid file format.");
            console.error("Error loading file:", err);
        }
    };
    reader.readAsText(file);
}

// Function to restore the specific block state during loading
// Function to restore the specific block state during loading
// Function to restore the specific block state during loading
function restoreBlockState(block, state,row=null,col=null) {
setTimeout(()=>{
    if (!block) return;

    if (block.name === "steam crank") {
        gridData[row][col].flow = state; // Set the flow state directly
        gridData[row][col].updateImg(row,col); // Update the crank image based on the restored flow
    } else if (block.name === "steam door") {
         gridData[row][col].state = state; // Set the door state directly
          gridData[row][col].updateImg(row,col); // Update the door image based on state
    }
	},500)
}


// Function to reset the grid visually and in gridData
function resetGrid() {
    for (let i = 0; i < 10000; i++) {
        const cell = document.getElementById(`grid-cell-${i}`);
        if (cell) {
            cell.innerHTML = '';
            cell.style.border = '1px solid rgba(60,50,120,0.5)';
        }
    }
    gridData = Array.from({ length: 100 }, () => Array(100).fill(null)); // Reset gridData
}


		//audio controls
		
		// Create an AudioContext		
		let audioContext = null;
		document.body.onclick = function(){
		if(audioContext)
			return;
		audioContext = new (window.AudioContext || window.webkitAudioContext)()
		};

		// Function to play a tone
		function playTone(frequency, duration) {
			const oscillator = audioContext.createOscillator();
			oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
			oscillator.type = 'sine';
			oscillator.connect(audioContext.destination);
			oscillator.start();
			oscillator.stop(audioContext.currentTime + duration);
		}

		

	
		let grid_view_toggle = false;

		function showGridBorder() {
			Array.from(document.getElementsByClassName("grid-cell")).forEach((e)=>{
				e.style.border = "2px groove rgba(0,0,0,0)"
			})
		}

		function hideGridBorder() {
		Array.from(document.getElementsByClassName("grid-cell")).forEach((e)=>{
			 e.style.border = "2px groove  rgba(60,50,150,0.3)"
			 })
		}




		//toggle grid shortcut
		document.addEventListener('keydown', function(event) {
			if (event.key === 'g' || event.key === 'G') {
				grid_view_toggle = !grid_view_toggle;
				if (grid_view_toggle) {
					showGridBorder()
				} else {
					hideGridBorder()
				}
			}
		});
		
		
		
		
		
		
		//toggle grid for mobile
		function mobileToggle(){
		grid_view_toggle = !grid_view_toggle;
				if (grid_view_toggle) {
					showGridBorder()
				} else {
					hideGridBorder()
				}
		}
	
	
	
	
	
	
		function unique(length) {
		let result = '';
		const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
		const charactersLength = characters.length;
		let counter = 0;
		while (counter < length) {
		  result += characters.charAt(Math.floor(Math.random() * charactersLength));
		  counter += 1;
		}
		return result;
	}

        let inventoryVisible = false;


		
		
		
		
        function toggleInventory() {
            const invCont = document.getElementById('inv-cont');
            const toggleHint = document.getElementById('toggle-hint');
            
            if (inventoryVisible) {
                invCont.style.display = 'none';
               // toggleHint.style.display = 'block'; // Show the hint text
            } else {
                invCont.style.display = 'block';
               // toggleHint.style.display = 'none'; // Hide the hint text
            }

            inventoryVisible = !inventoryVisible; // Toggle state
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'i' || event.key === 'I') {
                toggleInventory();
            }
            if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                event.preventDefault(); // Prevent the default save dialog
				alert("not currently functional, sorry")
				return;
                saveGrid();
            }
        });
		
		
		
		//important constants
		const true_puff_speed = 100
		const collector_puff_speed = 300;//0.1s (default)
		const max_puff_distance = 99;//99 (based on actual game)
		const global_collector_max_duration = 10;
		const global_vent_max_duration = 3000 //3 sec
		const global_organ_max_duration = 100;
		
		//variable puff speed
		let puff_speed = true_puff_speed ;//0.1s (default)

        
        const items = [
            { name: "steam tubes" },
			{ name: "steam gear" },
            { name: "steam bellows" },
            { name: "steam riser bellows" },
            { name: "steam piston" },
            { name: "steam lifter piston" },
            { name: "steam collector" },            
            { name: "steam funnel up" },
            { name: "steam funnel down" },
            { name: "steam funnel left" },
            { name: "steam funnel right" },
			{ name: "steam crank" },
			{ name: "steam valve left" },
			{ name: "steam valve right" },
			{ name: "steam crossover URDL" },
			{ name: "steam crossover ULDR" },
			{ name: "steam scrambler" },      
			{ name: "steam organ" },			
            { name: "steam pipe",hide:null},
			{ name: "steam vent L" },     
			{ name: "steam vent R" },   	
            { name: "steam revolver" },
			{ name: "steam stomper" },
			{ name: "steam engine L" },     
			{ name: "steam engine R" },   			
            { name: "steam door" },
			{ name: "steam launcher" },
            { name: "steam spikes" },
            { name: "steam lamp" },
           
			{ name: "copper" }
        ];
		
		
		
		  const standard_behaviour = [ 
            "steam tubes",
            "steam bellows" ,
            "steam riser bellows",
            "steam piston",
            "steam lifter piston",		
            "steam gear",
			
			
			"steam valve left",
			"steam valve right",
			"steam crank",
			"steam collector",
			"steam crossover URDL",
			"steam crossover ULDR",
			"steam vent L",
			"steam vent R",
		    "steam organ",
			
			"steam door" 
        ];
		
		
		const activators = [    
            { name: "steam revolver" },
            { name: "steam stomper" },
			{ name: "steam engine L" },
			{ name: "steam engine R" },
			
			{ name: "steam door" }
        ];
		
		const single_powered = [    
            { name: "steam door" }
        ];


        let selectedItem = null;
        let gridData = Array.from({ length: 100 }, () => Array(100).fill(null)); // 2D array for grid

        const inv = document.getElementById('inv');
        const grid = document.getElementById('grid');
        const fileInput = document.getElementById('file-input');

        items.forEach(item => {
			if(item.hasOwnProperty("hide")){
				return; //equal to continue in forEach
				}
				
            const div = document.createElement('div');
            div.classList.add('inv-item');
            
            const img = document.createElement('img');
            img.src = "assets/" + item.name.toLowerCase().replaceAll(" ", "-") + ".png";
            img.alt = item.name;

            div.addEventListener('click', () => {
                selectedItem = { name: item.name, orientation: 0 };
            });

            div.appendChild(img);
            inv.appendChild(div);
        });

        


        //GENERATE MAIN 100 BY 100 GRID
        function GenerateMainGrid(){
			for (let i = 0; i < 10000; i++) {
				const cell = document.createElement('div');
				cell.id = `grid-cell-${i}`
				cell.classList.add('grid-cell');

				cell.addEventListener('click', () => placeBlock(cell, i));
				grid.appendChild(cell);
			}
		}
		
		
		
		//WHEN PAGE IS FULLY LOADED
		window.onload = function(){
			setTimeout(toggleInventory, 1000);
			setTimeout(toggleInventory, 1000);
			GenerateMainGrid()
		}
		
		
		
		
		
		
		//changing image of a block in grid at row,col
		function changeBlockImage(row, col, image) {
			const cell = document.getElementById(`grid-cell-${row * 100 + col}`);
			if (cell && cell.hasChildNodes()) {
				const img = cell.querySelector('img');
				if (img) {
					img.src = image;
				}
			}
		}


		//main function to handle placing blocks on the grid
//main function to handle placing blocks on the grid
		function placeBlock(cell, i, control="build", saved_value=[]) {
			const row = Math.floor(i / 100);
			const col = i % 100;

			if (cell.hasChildNodes()) {
				cell.innerHTML = '';
				cell.style.border = '1px solid rgba(60,50,120,0.5)';
				gridData[row][col] = "null";

				const existingButton = document.getElementById(`activator-${i}`);
				if (existingButton) {
					document.body.removeChild(existingButton);
				}
			} else if (selectedItem) {
				const img = document.createElement('img');
				img.src = "assets/" + selectedItem.name.toLowerCase().replaceAll(" ", "-") + ".png";
				img.alt = selectedItem.name;
				cell.appendChild(img);
				cell.style.border = 'none';

				//handling how the object should be, depending on block
				//this can be overwritten later
				gridData[row][col] = {
					name: selectedItem.name
				};


				//handle valve block placement
				if (selectedItem.name.includes("valve")) {
					let _orientation = (selectedItem.name.includes("left")) ? "L" : "R";
					gridData[row][col] = new steam_valve(selectedItem.name, _orientation);
					console.log("valve placed-> " + gridData[row][col].orientation);
					return;
				}


				//handle steam collector block placement
				if (selectedItem.name.includes("collector")) {
					gridData[row][col] = new Steam_Collector(selectedItem.name, 0);
					console.log("steam collector placed");
					return;
				}



				//block is an activator block, create activator button, (standard for all non continuous steam generators)
				if (activators.some(a => a.name === selectedItem.name) && !selectedItem.name.includes(" door") && !selectedItem.name.includes(" crank") && !selectedItem.name.includes(" vent")) {
					let button = document.createElement("button");
					button.id = `activator-${i}`;
					button.classList.add("activators");
					button.textContent = "â–¶ï¸";

					button.style.top = `${Math.floor(i / 100) * 40}px`;
					button.style.left = `${(i % 100) * 40}px`;
					button.addEventListener("click", () => {
						console.log("activator button active")
						console.log(selectedItem.name)
						steamSystem_main(Math.floor(i / 100), i % 100,	selectedItem.name)
					});

					document.body.appendChild(button);
					button.style.opacity = "0.9"
					return;
				}

				//placing a steam crank
				if (selectedItem.name.includes("steam crank")) {
				
					let crank = new steam_crank(selectedItem.name);
					gridData[row][col] = crank;
					
					if(control == "load"){
						gridData[row][col].flow = saved_value[0];
					}

					let button = document.createElement("button");
					button.id = `activator-${i}`;
					button.classList.add("activators");
					button.textContent = "ï¸ðŸ”„";
					button.style.top = `${Math.floor(i / 100) * 40}px`;
					button.style.left = `${(i % 100) * 40}px`;

					button.addEventListener("click", () => {
						crank.toggleFlow();
						changeBlockImage(row, col, crank.getImage());
						console.log("steam crank rotated");
					});

					document.body.appendChild(button);
					return;
				}


				//placing a steam organ
				if (selectedItem.name.includes("steam organ")) {
					console.log("organ placed");
					let organ = new Steam_Organ(selectedItem.name, "off");
					gridData[row][col] = organ;
				}

				//placing a steam door
				if (selectedItem.name.includes("door")) {
					console.log('steam door placed');
					let door = new steam_door(selectedItem.name, "closed", row, col);
					gridData[row][col] = door; // Store the door in the grid

					let button = document.createElement("button");
					button.id = `activator-${i}`;
					button.classList.add("activators");
					button.textContent = "ï¸ðŸ”˜";
					button.style.top = `${Math.floor(i / 100) * 40}px`;
					button.style.left = `${(i % 100) * 40}px`;

					// Add event listener to toggle the state
					button.addEventListener("click", () => {
						let currentDoor = gridData[row][col]; // Get the existing door from the grid
						currentDoor.toggleState(); // Toggle the door's state
						changeBlockImage(row, col, currentDoor.getImage()); // Update the image
						console.log("steam door state changed: " + currentDoor.state);
					});

					document.body.appendChild(button);
					return;
				}

				if (selectedItem.name.includes("vent")) {
					let vent_direction = (selectedItem.name.includes("L") ? "L" : "R");
					console.log("vent placed + " + vent_direction);
					let vent = new steam_vent(selectedItem.name, "off", vent_direction);

					gridData[row][col] = vent; // Store the vent in the grid-cell
					return;
				}

			}
		} 

			  

		//get data of blocks adjacent to input (row,col)
		function adj(row, col) {
			const adjacent = [];
			const rows = gridData.length;
			const cols = gridData[0].length;

			// Up
			let upBlock = row > 0 ? gridData[row - 1][col] || "null" : "null";
			if (upBlock !== "null" && upBlock.hasOwnProperty('name') && upBlock.name.includes("valve")) {
				adjacent.push(upBlock); // If vent is above, allow it
			} else {
				adjacent.push(upBlock); // Otherwise, behave as normal
			}

			// Down
			let downBlock = row < rows - 1 ? gridData[row + 1][col] || "null" : "null";
			if (downBlock !== "null" && downBlock.hasOwnProperty('name') && downBlock.name.includes("valve")) {
				adjacent.push(downBlock); // If vent is below, allow it
			} else {
				adjacent.push(downBlock); // Otherwise, behave as normal
			}

			// Left
			let leftBlock = col > 0 ? gridData[row][col - 1] || "null" : "null";
			if (leftBlock !== "null" && leftBlock.hasOwnProperty('name') && leftBlock.name.includes("valve")) {
				leftBlock = "null"; // If vent is on the left, treat it as null
			}
			adjacent.push(leftBlock);

			// Right
			let rightBlock = col < cols - 1 ? gridData[row][col + 1] || "null" : "null";
			if (rightBlock !== "null" && rightBlock.hasOwnProperty('name') && rightBlock.name.includes("valve")) {
				rightBlock = "null"; // If vent is on the right, treat it as null
			}
			adjacent.push(rightBlock);

			console.log(adjacent);
			return adjacent;
		}
		
		const arrow_mapper = {
			U:"âˆ§",
			D:"âˆ¨",
			L:"<",
			R:">"
		}
		
		
		
		function getBlockData(row,col){
			let cell = document.getElementById(`grid-cell-${row * 100 + col}`)
			let in_grid = gridData[row][col]
			return in_grid;
		}	




		
		
		//unused template
		class general_steam_component {
			constructor(name){
				this.name = name;
			}
		}
		
		
		
		
		//steam vent class
		class steam_vent {
			constructor(name, state = "off", vent_direction) {
				this.name = name;
				this.state = state;
				this.vent_direction = vent_direction;
				this.timeout = null; // Keep track of the timeout
			}

			// Activate function to turn on the vent, wait, then turn it off
			activate(row, col) {
				// Always reset vent duration on activation
				console.log('vent activated, resetting duration');

				// Turn the vent "on"
				this.state = "on";
				changeBlockImage(row, col, "assets/steam-vent-" + this.vent_direction + "-on.png");

				// Clear any existing timeout to avoid multiple overlapping timeouts
				if (this.timeout) {
					clearTimeout(this.timeout);
					console.log('previous vent timeout cleared');
				}

				// Set a new timeout to turn off the vent after the specified duration
				this.timeout = setTimeout(() => {
					this.state = "off";
					changeBlockImage(row, col, "assets/steam-vent-" + this.vent_direction + ".png");
					console.log('vent off');
					this.timeout = null; // Reset the timeout variable
				}, global_vent_max_duration); // Use the global vent duration
			}
		}
		
		
		
		
		//steam collector class (work in progress)
		class Steam_Collector {
			constructor(name, steam_puff_count=0){
				this.name = name;
				this.steam_puff_count = steam_puff_count;
			}
		}
		
		
		//steam organ class
		class Steam_Organ {
			constructor(name,state="off",audio=1000){
				this.name = name;
				this.audio = audio;
				this.state = state;
				this.timeout = null;
			}
			
			activate(row, col) {
				console.log('organ activated, resetting duration');
				
				this.state = "on";
				changeBlockImage(row, col, "assets/steam-organ-on.png");
				playTone(this.audio, global_organ_max_duration/1000) 

				// Clear any existing timeout to avoid multiple overlapping timeouts
				if (this.timeout) {
					clearTimeout(this.timeout);
					console.log('previous vent timeout cleared');
				}

				// Set a new timeout to turn off the organ after the specified duration
				this.timeout = setTimeout(() => {
					this.state = "off";
					changeBlockImage(row, col, "assets/steam-organ.png");
					console.log('organ off');
					this.timeout = null; 
				}, global_organ_max_duration); 
			}
			
		}

		
		
		
		
		
		//steam door class
		class steam_door {
			constructor(name, state, row, col) {
				this.name = name;
				this.state = state;
				this.row = row;
				this.col = col;
			}

			toggleState() {
				this.state = this.state === "closed" ? "open" : "closed";
			}

			getImage() {
				return this.state === "closed" ? "assets/steam-door.png" : "assets/steam-door-open.png";
			}
			updateImg(row,col){
				changeBlockImage(row,col,this.getImage())
			}
		}

		
		
		
		// steam crank class
		class steam_crank {
			constructor(name, flow = "vertical") {
				this.name = name;
				this.flow = flow;
			}

			toggleFlow() {
				if (this.flow === "vertical") {
					this.flow = "horizontal";
				} else {
					this.flow = "vertical";
				}
			}
			
			// Method to update the crank image on the grid
			updateImg(row, col) {
				changeBlockImage(row, col, this.getImage()); // Update image based on flow state
				console.log("flow:"+this.flow+" "+this.getImage())
			}

			getImage() {
				return this.flow === "vertical" ? 'assets/steam-crank.png' : 'assets/steam-crank-horizontal.png';
			}
		}


		
		
		//steam valve class
		class steam_valve {
			constructor(name,orientation){
				this.name = name;
				this.orientation = orientation;
			}
			switch_orientation(){
				if(this.orientation == "L"){
					this.orientation = "R";
					console.log("new orientation:"+this.orientation)
				}
				else if(this.orientation == "R"){
					this.orientation = "L";
					console.log("new orientation:"+this.orientation)
				}
			}
		}




		//steam puff mechanics
		let Steam_Puffs = []
		const id_length = 5;
		
		
		class Puff {
			constructor(current_direction,position={row:null,col:null},distance_moved=0,collector_max_duration=global_collector_max_duration,unique_id,foundSpot = false,ele=null){
				this.current_direction = current_direction;
				this.position = position
				this.unique_id = unique(id_length);
				this.distance_moved = distance_moved;
				this.collector_max_duration = collector_max_duration;
				this.generate_puff(this.position.row,this.position.col)	
				this.foundSpot = foundSpot;
				this.ele = ele;
			}
			
			//generate a new steam puff visually
			generate_puff(row,col){
				 let cell = document.getElementById(`grid-cell-${ parseInt(this.position.row) * 100 + parseInt(this.position.col)}`);
			     if (cell) {
					// Create and display a new steam puff element
					const puffElement = document.createElement('div');
					puffElement.id = "puff-" + this.unique_id
					puffElement.innerHTML = this.current_direction
					puffElement.style.opacity = 0.7
					puffElement.classList.add('steam-puff');
					puffElement.style.top = '0px'; 
					puffElement.style.left = '0px'; 
					this.distance_moved+=1
					this.ele = puffElement;
					Steam_Puffs.push(this);
					cell.appendChild(puffElement)
					setTimeout(()=>{this.recursive_move()},puff_speed)
				 }
	 
		}
		
		
		
		//method to kill puff
		kill_puff(){	
		try{
				console.log(document.getElementById("puff-" + this.unique_id))
				document.getElementById("puff-" + this.unique_id).remove();
				Steam_Puffs.splice(Steam_Puffs.indexOf(Steam_Puffs.filter(a=>a.unique_id==this.unique_id)[0]),1);
				}
				catch(e){return}
				return;
		}
		
		//method to check if puff has found a spot to move to, if not kill the puff
		check_found_spot(){
			console.log('found spot:'+this.foundSpot)
			
			if(this.foundSpot == false){
					this.kill_puff();
					return;
				}
				
		}
		
		
		
		//recursive motion function
			recursive_move(){
				
									
				this.foundSpot = false; 
				
				console.log('moved/max:'+this.distance_moved+"/"+max_puff_distance)
				if(this.distance_moved==max_puff_distance){
					//kill steam puff
					this.kill_puff()
					console.log("puff kill was attempted- max distance")
					return;
				}
			
				let adjCells = adj(this.position.row,this.position.col);
				
				//adjacent cells validity checks
				let ValidArr = {
				  U: adjCells[0] !== null && adjCells[0] !== undefined && adjCells[0].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[0].name) || adjCells[0].name.includes("funnel")), // up

				  D: adjCells[1] !== null && adjCells[1] !== undefined && adjCells[1].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[1].name) || adjCells[1].name.includes("funnel")), // down

				  L: adjCells[2] !== null && adjCells[2] !== undefined && adjCells[2].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[2].name) || adjCells[2].name.includes("funnel")), // left

				  R: adjCells[3] !== null && adjCells[3] !== undefined && adjCells[3].hasOwnProperty('name') &&
					 (standard_behaviour.includes(adjCells[3].name) || adjCells[3].name.includes("funnel"))  // right
				};
				
				
				
				
				//if its currently at an organ, activate organ
				if(gridData[this.position.row][this.position.col].name.includes("organ")){
					console.log("currently in steam organ");
					gridData[this.position.row][this.position.col].activate(this.position.row,this.position.col);
				}
				
				
				
				//slow down speed if in steam collector
				if(gridData[this.position.row][this.position.col].name.includes("collector")){
					console.log("slowing puff down..."+puff_speed);
					puff_speed = collector_puff_speed;
				}
				else{
					//if not use regular speed
					console.log("puff_speed_reset"+puff_speed);
					puff_speed = true_puff_speed;
				}
				
				
			
				
				
				//ULDR steam crossover handler
				if (gridData[this.position.row][this.position.col].name.includes("ULDR")) {
					console.log("Currently in ULDR crossover");

					// Check if adjacent cells are valid before changing direction
					if (this.current_direction == "U" && ValidArr["R"]) {
						this.changePosition("R", this.position.row, this.position.col+1);
					} else if (this.current_direction == "D" && ValidArr["L"]) {
						this.changePosition("L", this.position.row, this.position.col-1);
					} else if (this.current_direction == "L" && ValidArr["D"]) {
						this.changePosition("D", this.position.row+1, this.position.col);
					} else if (this.current_direction == "R" && ValidArr["U"]) {
						this.changePosition("U", this.position.row-1, this.position.col);
					} else {
						// If no valid move, kill the puff
						this.kill_puff();
					}

					this.check_found_spot();
					setTimeout(() => { this.recursive_move(); }, puff_speed);
					return;
				}
				
							
				// URDL steam crossover handler
				if (gridData[this.position.row][this.position.col].name.includes("URDL")) {
					console.log("Currently in URDL crossover");

					// Check if adjacent cells are valid before changing direction
					if (this.current_direction == "U" && ValidArr["L"]) {
						this.changePosition("L", this.position.row, this.position.col-1);
					} else if (this.current_direction == "D" && ValidArr["R"]) {
						this.changePosition("R", this.position.row, this.position.col+1);
					} else if (this.current_direction == "L" && ValidArr["U"]) {
						this.changePosition("U", this.position.row-1, this.position.col);
					} else if (this.current_direction == "R" && ValidArr["D"]) {
						this.changePosition("D", this.position.row+1, this.position.col);
					} else {
						// If no valid move, kill the puff
						this.kill_puff();
					}

					this.check_found_spot();
					setTimeout(() => { this.recursive_move(); }, puff_speed);
					return;
				}

				
				
				//currently in a steam door block
				if(gridData[this.position.row][this.position.col].name.includes("door")){
					gridData[this.position.row][this.position.col].toggleState();
					document.getElementById("puff-" + this.unique_id).style.opacity = "0"
					changeBlockImage(this.position.row,this.position.col,gridData[this.position.row][this.position.col].getImage());
					
					this.kill_puff();
					return;
				}
				
				
				
				//currently puff is in a funnel block, handle movement from funnel
				if(getBlockData(this.position.row,this.position.col).name.includes("funnel")){
					console.log('currently in funnel')
					
					if(getBlockData(this.position.row,this.position.col).name.includes("up")){
						if(ValidArr["U"]){
							console.log('up funnel')
							this.changePosition("U",this.position.row-1,this.position.col)
						}
					}
					else if(getBlockData(this.position.row,this.position.col).name.includes("down")){
						if(ValidArr["D"]){
							console.log('down funnel')
							this.changePosition("D",this.position.row+1,this.position.col)
						}
					}
					else if(getBlockData(this.position.row,this.position.col).name.includes("left")){
						if(ValidArr["L"]){
							console.log('left funnel')
							this.changePosition("L",this.position.row,this.position.col-1)
						}
					}
					else if(getBlockData(this.position.row,this.position.col).name.includes("right")){
						if(ValidArr["R"]){
							console.log('right funnel')
							this.changePosition("R",this.position.row,this.position.col+1)
						}
					}
					
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
						return;
				}
				
				
				
				
				
			


				
				//prevent back flow of steam, note applies for collectors, collectors go below this
				if(this.current_direction=="U"){
				 ValidArr.D = null
				}
				if(this.current_direction=="D"){
				 ValidArr.U = null
				}
				if(this.current_direction=="L"){
				 ValidArr.R = null
				}
				if(this.current_direction=="R"){
				 ValidArr.L = null
				}
				
				
					if(adjCells[2].hasOwnProperty("name")&&adjCells[2].name.includes("vent")){
				    	adjCells[2] = null
						ValidArr["L"] = null						
					}
					if(adjCells[3].hasOwnProperty("name")&&adjCells[3].name.includes("vent")){					
						adjCells[3] = null
						ValidArr["R"] = null
					}
					
				
				
				
				
				//currently puff is in a valve block, handle movement from valve
				if(gridData[this.position.row][this.position.col].name.includes("valve")){
					console.log("valve encountered")
					let valve = gridData[this.position.row][this.position.col]
					
					
					//check if exit direction of valve leads to a valid block
					//check if standard valve behaviour is possible
					if(ValidArr[valve.orientation]!="null"&&ValidArr[valve.orientation]!=null){
						//valve leads to valid block				
							console.log('valve attempt valid exit:'+valve.orientation);
							if(valve.orientation=="L"){
								this.changePosition("L",this.position.row,this.position.col)
								valve.switch_orientation();
								console.log("switched orientation:"+valve.orientation)
							}
							else if(valve.orientation=="R"){
								this.changePosition("R",this.position.row,this.position.col)
								valve.switch_orientation();
								console.log("switched orientation:"+valve.orientation)
							}							
					}
					
					//if standard behaviour is not possible, leads to invalid
					//go straight direction
					else{
						if(this.current_direction=="U"){
						if(ValidArr["U"]!="null"&&ValidArr["U"]!=null){
							this.changePosition("U",this.position.row,this.position.col);
							}
							}
							else if(this.current_direction=="D"){
						if(ValidArr["D"]!="null"&&ValidArr["D"]!=null){
							this.changePosition("D",this.position.row,this.position.col);
							}
							}
							else{
								this.kill_puff()
							}
						
							
						valve.switch_orientation();
						console.log("switched orientation:"+valve.orientation)
					}
					
					

					
					
					this.check_found_spot();
					
				}
				
				
				
					
				
				
				
				
				
				
				
				
				//steam crank system to prevent motion to improper crank
				//obtaining current block infront of steam puff
				let adj_block = adj(this.position.row,this.position.col)
				let block;
				if(this.current_direction=="U"){
					block = adj_block[0]
				}
				if(this.current_direction=="D"){
					block = adj_block[1]
				}
				if(this.current_direction=="L"){
					block = adj_block[2]
				}
				if(this.current_direction=="R"){
					block = adj_block[3]
				}
				
				//steam crank system to prevent motion to improper crank
				if(block.hasOwnProperty("name")){
				if(block.name.includes("crank")){
					if(this.current_direction=="U"&&block.flow=="horizontal"){
						alert("v")
						ValidArr.U = null
					}
					if(this.current_direction=="D"&&block.flow=="horizontal"){
						ValidArr.D = null
					}
					if(this.current_direction=="L"&&block.flow=="vertical"){
						ValidArr.L = null
					}
					if(this.current_direction=="R"&&block.flow=="vertical"){
						ValidArr.R = null
					}
					
					
				}
				}
				
				
				
				if(adj_block[1].hasOwnProperty("flow")){			
						if(this.current_direction=="L"&&adj_block[1].flow=="horizontal"){
							ValidArr["D"] = null
							adj_block[1] = null
						}
						if(this.current_direction=="R"&&adj_block[1].flow=="horizontal"){
							ValidArr["D"] = null
							adj_block[1] = null
						}
					}
				if(adjCells[0].hasOwnProperty("flow")){			
						if(this.current_direction=="L"&&adjCells[0].flow=="horizontal"){
							ValidArr["U"] = null
							adjCells[0] = null
						}
						if(this.current_direction=="R"&&adjCells[0].flow=="horizontal"){
							ValidArr["U"] = null
							adjCells[0] = null
						}
					}
					
					
				if(adj_block[2].hasOwnProperty("flow")){			
						if(this.current_direction=="D"&&adj_block[2].flow=="vertical"){
							ValidArr["L"] = null
							adj_block[2] = null
						}
						if(this.current_direction=="U"&&adj_block[2].flow=="vertical"){
							ValidArr["L"] = null
							adj_block[2] = null
							
						}
					}
					
				if(adj_block[3].hasOwnProperty("flow")){			
						if(this.current_direction=="D"&&adj_block[3].flow=="vertical"){
							ValidArr["R"] = null
							adj_block[3] = null
						}
						if(this.current_direction=="U"&&adj_block[3].flow=="vertical"){
							ValidArr["L"] = null
							adj_block[3] = null
						}
					}
					
				
				
				
				//vent system (new)
				if (gridData[this.position.row][this.position.col].name.includes("vent")) {
				// Activate the vent
				gridData[this.position.row][this.position.col].activate(this.position.row, this.position.col);
					if(ValidArr[this.current_direction]==true){ 
					if(this.current_direction=="U")
						this.changePosition("U",this.position.row,this.position.col);
					if(this.current_direction=="D")
						this.changePosition("D",this.position.row,this.position.col);
					}
					else{
						this.kill_puff()
					}
				}
				
				
				
				
				if(ValidArr[this.current_direction]==true){ //can move straight
					console.log("straight line motion");
					if(this.current_direction=="U")
						this.changePosition("U",this.position.row-1,this.position.col);
					if(this.current_direction=="D")
						this.changePosition("D",this.position.row+1,this.position.col);
					if(this.current_direction=="L")
						this.changePosition("L",this.position.row,this.position.col-1);
					if(this.current_direction=="R")
						this.changePosition("R",this.position.row,this.position.col+1);
					
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				
				//right movement puff logic
				else if(this.current_direction=="U" && ValidArr["R"] ){
					this.changePosition("R",this.position.row,this.position.col+1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				else if(this.current_direction=="D" && ValidArr["L"] ){
					this.changePosition("L",this.position.row,this.position.col-1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				else if(this.current_direction=="L" && ValidArr["U"] ){
					this.changePosition("U",this.position.row-1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				else if(this.current_direction=="R" && ValidArr["D"] ){
					this.changePosition("D",this.position.row+1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				
				//left movement puff logic
				else if(this.current_direction=="U" && ValidArr["L"] ){
					this.changePosition("L",this.position.row,this.position.col-1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				else if(this.current_direction=="D" && ValidArr["R"] ){
					this.changePosition("R",this.position.row,this.position.col+1);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				else if(this.current_direction=="L" && ValidArr["D"] ){
					this.changePosition("D",this.position.row+1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				else if(this.current_direction=="R" && ValidArr["U"] ){
					this.changePosition("U",this.position.row-1,this.position.col);
					this.check_found_spot();
					setTimeout(()=>{this.recursive_move()},puff_speed)
				}
				
				this.check_found_spot();
			}
			
			
			//change puff position in grid
				changePosition(newDirection, newRow, newCol) {
				// Get the current cell and new cell in the grid
				const currentCell = document.getElementById(`grid-cell-${this.position.row * 100 + this.position.col}`);
				const newCellIndex = newRow * 100 + newCol;
				const newCell = document.getElementById(`grid-cell-${newCellIndex}`);

				// Find the puff element in the current cell
				const puffElement = document.getElementById(`puff-${this.unique_id}`);
				if (puffElement) {
					// Remove puff element from the current cell
					if (currentCell) {
						currentCell.removeChild(puffElement);
					}

					// Append puff element to the new cell
					if (newCell) {
						puffElement.style.top = "0px"
						puffElement.style.left = "0px"
						this.current_direction = newDirection;
						//increment distance moved
						this.distance_moved += 1;
						let scaledValue = Math.round((this.distance_moved / 99) * 255); // Scale distance to 1-255 range
						puffElement.style.backgroundColor = "rgb(" + scaledValue + "," + (255 - scaledValue) + ",30)";
						puffElement.innerHTML = this.distance_moved + "-"+this.current_direction

						this.foundSpot = true;
						newCell.appendChild(puffElement);
					}

					// Update puff's position
					this.position = {row:newRow, col:newCol};
				}
			}

		}

		
			
			

       function steamSystem_main(act_r, act_c, provider="") {
			console.log(gridData);
			
			let adjCells = adj(act_r, act_c); // Get adjacent cells

			// Function to check if a cell is valid
			function isValidCell(cell) {
				return cell !== null && cell !== undefined && cell.hasOwnProperty('name');
			}

			// Function to check if propagation should occur
			function shouldPropagate(cell) {
				return standard_behaviour.includes(cell.name) || cell.name.includes("funnel");
			}

			// Function to handle puff propagation
			function handlePuff(direction, newRow, newCol) {
				let _puff = new Puff(direction, { row: newRow, col: newCol });
			}

			// Check and handle "sus crank" for a specific cell
			function checkSusCrank(row, col, directionIndex) {
				const cell = gridData[row][col];
				if (cell.name.includes("crank") && cell.flow === "horizontal") {
					console.log("Caught sus crank, treating as null");
					adjCells[directionIndex] = null; // Treat this cell as null
					return true; // Crank detected
				}
				return false; // No crank detected
			}

			// Main propagation logic
			function propagate() {
			console.log(provider)
				if (isValidCell(adjCells[0]) && shouldPropagate(adjCells[0])&&!provider=="steam stomper") {
				console.log(provider)
					// Check for sus crank and treat as null if found
					if (checkSusCrank(act_r - 1, act_c, 0)) {
						propagate(); // Retry after marking crank as null
						return;
					}
					// Move up
					handlePuff("U", act_r - 1, act_c);
				} 
				else if (isValidCell(adjCells[1]) && shouldPropagate(adjCells[1])) {
					// Check for sus crank and treat as null if found
					if (checkSusCrank(act_r + 1, act_c, 1)) {
						propagate(); // Retry after marking crank as null
						return;
					}
					// Move down
					handlePuff("D", act_r + 1, act_c);
				} 
				else {
					// No valid direction to propagate to
					console.log("No valid direction for puff propagation");
				}
			}

			// Initial propagation attempt
			propagate();
		}

	
</script>
</body>
</html>
